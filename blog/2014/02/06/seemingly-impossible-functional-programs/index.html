<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Seemingly impossible functional programs - williamdemeo.github.io</title>
  <meta name="author" content="William DeMeo">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://williamdemeo.github.io/blog/2014/02/06/seemingly-impossible-functional-programs">
  <link href="/favicon.png" type="image/png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="williamdemeo.github.io" type="application/atom+xml">

  <link href="/assets/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<!-- MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"], 
    jax: ["input/TeX","output/HTML-CSS"], 
    tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ['\[','\]'] ], 
    processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




  <script src="/javascripts/libs/jquery/jquery-2.0.3.min.js"></script>
  

</head>

  <body   >
    <div id="wrap">
      <header role="banner">
        <nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">williamdemeo.github.io</a>
        </div>

        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a href="/">Blog</a>
                </li>
                <li >
                    <a href="/blog/archives">Archives</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="subscribe-rss" href="/atom.xml" title="subscribe via RSS">
                        <span class="visible-xs">RSS</span>
                        <img class="hidden-xs" src="/images/rss.png" alt="RSS">
                    </a>
                </li>
                
            </ul>
            
                <form class="search navbar-form navbar-right" action="http://google.com/search" method="GET">
                    <input type="hidden" name="q" value="site:williamdemeo.github.io">
                    <div class="form-group">
                        <input class="form-control" type="text" name="q" placeholder="Search">
                    </div>
                </form>
            
        </div>
    </div>
</nav>


      </header>
      <div id="main" class="container">
        <div id="content">
          <div class="row">
  <div class="page-content col-md-9">
    <article class="hentry" role="article">
      
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-02-06T16:40:23-05:00" pubdate data-updated="true">Feb 6<span>th</span>, 2014</time>
        
      </p>
    
    
    <h1 class="entry-title">
        Seemingly Impossible Functional Programs
        
    </h1>
    
  </header>


<div class="entry-content clearfix"><p>These are some sketchy notes about 
<a href="http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/">Martin Escardo’s post</a>
of the same title. I recommend that you immediately go to Martin’s post on this
topic and ingore my derivative version.
<!-- more --></p>

<hr />

<p><strong>Claim:</strong> There are infinite sets that admit mechanical exhaustive search in finite time.</p>

<p><a href="http://www.cs.swan.ac.uk/~csulrich/">Ulrich Berger</a> (1990) discovered an
algorithm that performs exhaustive search over the <em>Cantor space</em> of infinite binary
sequences. </p>

<p>Many problems the following form:</p>

<ul>
  <li>Given a set $K$ and a property $p$, check whether or not all elements of $K$
satisfy $p$.</li>
</ul>

<p>We say that $K$ is <em>exhaustible</em> if this problem can be algorithmically solved
in finite time, for any <em>decidable</em> property $p$, uniformly in $p$. </p>

<p>Thus, the input of the algorithm is $p$ and the output is the truth value of the
statement that all elements of $K$ satisfy $p$. In the realm of
higher-type computability theory (see <a href="http://homepages.inf.ed.ac.uk/jrl/Research/notions1.pdf">Longley, 2003</a>), the algorithm has type
$(C \rightarrow B)\rightarrow B$, where $C$ is a type, $K \subseteq C$, and $B$
is the type of booleans, so that $(C \rightarrow B)$ is the type of decidable
predicates on $C$.</p>

<p>Clearly, finite sets of computable elements are exhaustible. What may be rather
unclear is whether there are infinite examples. </p>

<p>Intuitively, there can be none: how could one possibly check infinitely many
cases in finite time? </p>

<p>This intuition is correct when $K$ is a set of natural numbers: it is
a theorem that, in this case, $K$ is exhaustible if and only if it is
finite. </p>

<p>But a proof is non-trivial, usually by reduction to the halting problem, goes
beyond cardinality considerations, and relies on particular properties of the
set of natural numbers that don’t necessarily hold for other infinite sets.</p>

<p>Thus, the question remains, which kinds of infinite sets, if any, are
exhaustible? </p>

<p>It turns out that there is a rich supply. A first example, the Cantor set of
infinite sequences of binary digits, goes back to the 1950’s, as discussed in
the related-work paragraph below.</p>

<p><em>Weak form of exhaustive search:</em> check whether a total predicate holds for all
elements of the Cantor space. This amounts to universal quantification over the
Cantor space.</p>

<p>Can this possibly be done algorithmically, in finite time? </p>

<p><em>Stronger form:</em> find an example where the predicate holds, if such an example
exists, otherwise say there is no example.</p>

<h2 id="the-program">The program</h2>

<p>Represent the binary digits as a type called Bit:</p>

<pre><code>&gt; data Bit = Zero | One
&gt;          deriving (Eq)
</code></pre>

<p>The deriving clause tells Haskell to figure out how to decide equality of bits
automatically. </p>

<p>Regard sequences as functions defined on the natural numbers:</p>

<pre><code>&gt; type Natural = Integer
&gt; type Cantor = Natural -&gt; Bit
</code></pre>

<p>An object of type Cantor is a function that maps Natural type to Bit type.</p>

<p>The operator <code>(#)</code> takes a bit x and a sequence y and produces a new sequence 
<code>x # y</code> with x as the head and y as the tail:</p>

<pre><code>&gt; (#) :: Bit -&gt; Cantor -&gt; Cantor
&gt; x # a = \i -&gt; if i == 0 then x else a(i-1)
</code></pre>

<p><code>(#)</code> is defined using currying, but you can interpret
<code>(#) :: Bit -&gt; Cantor -&gt; Cantor</code> to mean that (#) takes a pair
(Bit, Cantor) and returns a Cantor. </p>

<p>Notice also that the notation <code>\i -&gt;</code> stands for $\lambda i$.</p>

<p>The <code>find</code> function will perform an exhaustive search over the Cantor space.
The specification of this function is that, for any total predicate <code>p</code>, 
<code>find p</code> is always a total element of the Cantor space, and, moreover, if there
is an <code>a</code> in the Cantor space with <code>p a = True</code>, then <code>a = find p</code> is an example of
such an <code>a</code>.</p>

<pre><code>&gt; forsome, forevery :: (Cantor -&gt; Bool) -&gt; Bool
&gt; find :: (Cantor -&gt; Bool) -&gt; Cantor
</code></pre>

<p>The function <code>find</code> takes a predicate on the Cantor space, and hence it will
typically have a $\lambda$-expression as argument. In the following definition
this is not necessary, because <code>(\a -&gt; p a) = p</code> by the $\eta$ rule. </p>

<p>Nonetheless, we use a $\lambda$-expression for clarity, and we can read 
<code>find(\a -&gt; p a)</code> as “find a such that p(a)”: </p>

<pre><code>&gt; forsome p = p(find(\a -&gt; p a))
&gt; forevery p = not(forsome(\a -&gt; not(p a)))
</code></pre>

<p>Notice that the function forevery (universal quantification) is obtained from
the function <code>forsome</code> (existential quantification) via DeMorgan’s Law. The
functionals <code>forsome</code> and <code>find_i</code> are defined by mutual recursion: </p>

<pre><code>&gt; find_i :: (Cantor -&gt; Bool) -&gt; Cantor
&gt; find_i p = if forsome(\a -&gt; p(Zero # a))
&gt;            then Zero # find_i(\a -&gt; p(Zero # a))
&gt;            else One  # find_i(\a -&gt; p(One  # a))
</code></pre>

<p>The intuitive idea of the algorithm <code>find_i</code> is clear: if there is an example
starting with zero, then the result is taken to start with zero, otherwise it
must start with one. Then we recursively build the tail using the same
idea. </p>

<p>What may not be clear is whether the recursion eventually produces a digit,
because of the indirect recursive call via the call to forsome. </p>

<p>A mathematical proof proceeds by induction on the modulus of uniform continuity
of p, defined below. </p>

<p>Common wisdom tells us that function types don’t have decidable equality. In
fact, e.g. the function type Integer -&gt; Integer doesn’t have decidable equality
because of the Halting Problem, as is well known. However, common wisdom is not
always correct, and, in fact, some other function types do have decidable
equality, for example the type Cantor -&gt; y for any type y with decidable
equality, without contradicting Turing:  </p>

<pre><code>&gt; equal :: Eq y =&gt; (Cantor -&gt; y) -&gt; (Cantor -&gt; y) -&gt; Bool
&gt; equal f g = forevery(\a -&gt; f a == g a)
</code></pre>

<p>This seems strange, even fishy, because the Cantor space is in some sense bigger
than the integers. This has to do with the fact that the Cantor space is
topologically compact, but the integers are not. </p>

<hr />
<p><strong>Example:</strong></p>

<pre><code>&gt; coerce :: Bit -&gt; Natural
&gt; coerce Zero = 0
&gt; coerce One = 1

&gt; f, g, h :: Cantor -&gt; Integer

&gt; f a = coerce(a(7 * coerce(a 4) +  4 * (coerce(a 7)) + 4))

&gt; g a = coerce(a(coerce(a 4) + 11 * (coerce(a 7))))

&gt; h a = if a 7 == Zero
&gt;       then if a 4 == Zero then coerce(a  4) else coerce(a 11)
&gt;       else if a 4 == One  then coerce(a 15) else coerce(a  8)
</code></pre>

<p>Now we call the ghci interpreter:</p>

<p>*Main&gt;</p>

<p>At this point we can evaluate expressions at the interpreter’s prompt. First I
ask it to print time and space usage after each evaluation: </p>

<pre><code>*Main&gt; :set +s
</code></pre>

<p>On a Dell 410 laptop running at 1.73GHz, Martin tests the following expressions:</p>

<pre><code>*Main&gt; equal f g
False
(0.10 secs, 3490296 bytes)

*Main&gt; equal f h
True
(0.87 secs, 36048844 bytes)

*Main&gt; equal g h
False
(0.09 secs, 3494064 bytes)

*Main&gt; equal f f
True
(0.91 secs, 38642544 bytes)

*Main&gt; equal g g
True
(0.15 secs, 6127796 bytes)

*Main&gt; equal h h
True
(0.83 secs, 32787372 bytes)
</code></pre>

<h2 id="references">References</h2>

<ul>
  <li>
    <p><a href="http://www.lmcs-online.org/ojs/viewarticle.php?id=395&amp;layout=abstract">Exhaustible sets in higher-type computation</a>, <a href="http://www.cs.bham.ac.uk/~mhe/">Martin Escardo</a> (2008)</p>
  </li>
  <li>
    <p><a href="http://www.cs.bham.ac.uk/~mhe/papers/exhaustive.pdf">Inﬁnite sets that admit fast exhaustive search</a>, <a href="http://www.cs.bham.ac.uk/~mhe/">Martin Escardo</a> (2007)</p>
  </li>
  <li>
    <p><a href="http://homepages.inf.ed.ac.uk/jrl/Research/notions1.pdf">Notions of computability at higher types I</a>, John R. Longley (2003)</p>
  </li>
  <li>
    <p><a href="http://www.sciencedirect.com/science/article/pii/0304397576900293">Computability concepts for programming language semantics</a>, Egli and Constable (1976)</p>
  </li>
  <li>
    <p><a href="http://www.sciencedirect.com/science/article/pii/0304397577900457">Effectively given domains</a>, M.B. Smyth (1977)</p>
  </li>
</ul>

</div>


      <footer>
        <p class="meta text-muted">
          
  

<span class="glyphicon glyphicon-user"></span> <span class="byline author vcard">Posted by <span class="fn">William DeMeo</span></span>

          












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-02-06T16:40:23-05:00" pubdate data-updated="true">Feb 6<span>th</span>, 2014</time>
          


        </p>
        
          <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://williamdemeo.github.io/blog/2014/02/06/seemingly-impossible-functional-programs/" data-via="" data-counturl="http://williamdemeo.github.io/blog/2014/02/06/seemingly-impossible-functional-programs/" >Tweet</a>
  
  
  
</div>

        
        
          <ul class="meta text-muted pager">
            
            <li class="previous"><a href="/blog/2014/02/05/diaconescus-theorem/" title="Previous Post: Diaconescu's Theorem">&laquo; Diaconescu's Theorem</a></li>
            
            
            <li class="next"><a href="/blog/2014/02/06/intuitionistic-type-theory/" title="Next Post: Intuitionistic type theory">Intuitionistic type theory &raquo;</a></li>
            
          </ul>
        
      </footer>
    </article>
    
  </div>

  
  <aside class="sidebar col-md-3">
    
      <section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Recent Posts</h3>
  </div>
  
  <div id="recent_posts" class="list-group">
    
    <a class="list-group-item " href="/blog/2014/02/06/computability-at-higher-types/">Computability at Higher Types</a>
    
    <a class="list-group-item " href="/blog/2014/02/06/intuitionistic-type-theory/">Intuitionistic Type Theory</a>
    
    <a class="list-group-item active" href="/blog/2014/02/06/seemingly-impossible-functional-programs/">Seemingly Impossible Functional Programs</a>
    
    <a class="list-group-item " href="/blog/2014/02/05/diaconescus-theorem/">Diaconescu's Theorem</a>
    
  </div>
</section>






    
  </aside>
  
</div>

        </div>
      </div>
    </div>
    <footer role="contentinfo"><div class="container">
    <p class="text-muted credits">
  Copyright &copy; 2014 - William DeMeo<br>
  <small>
      <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>,
      <span class="credit">customized with <a href="https://github.com/kAworu/octostrap3">octostrap3</a></span>.
  </small>
</p>

</div>
</footer>
    <script src="/assets/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/javascripts/modernizr-2.0.js"></script>








  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





  </body>
</html>
