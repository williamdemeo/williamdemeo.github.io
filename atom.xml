<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[William DeMeo]]></title>
  <link href="http://williamdemeo.github.io/atom.xml" rel="self"/>
  <link href="http://williamdemeo.github.io/"/>
  <updated>2017-12-06T21:19:29-07:00</updated>
  <id>http://williamdemeo.github.io/</id>
  <author>
    <name><![CDATA[William DeMeo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java on linux]]></title>
    <link href="http://williamdemeo.github.io/2017/12/06/java-on-linux/"/>
    <updated>2017-12-06T20:41:09-07:00</updated>
    <id>http://williamdemeo.github.io/2017/12/06/java-on-linux</id>
    <content type="html"><![CDATA[<p>This post describes the steps I use to update or install
multiple versions of the Java Development Kit (JDK) on 
Linux machines.</p>

<!-- more -->

<p>(These notes are mainly for my own reference, but also
come in handy when I need to something to point to when
a colleague or student needs to know how to do this.)</p>

<h3 id="download-the-latest-jdk-from-oracle">Download the latest JDK from Oracle</h3>

<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>

<p>I’ll assume we’re using Linux on an x64 machine, so we would,
for example, download a file with a name like <code>jdk-9.0.1_linux-x64_bin.tar.gz</code>.
(As of Dec 6, 2018, the direct link to this file is <a href="http://download.oracle.com/otn-pub/java/jdk/9.0.1+11/jdk-9.0.1_linux-x64_bin.tar.gz">here</a>.)</p>

<h3 id="unpack-the-targz-file-downloaded-in-the-previous-step">Unpack the tar.gz file downloaded in the previous step</h3>

<p>I’ll assume we downloaded the tar.gz file into the directory <code>~/opt/Java</code></p>

<pre><code>tar xvzf jdk-9.0.1_linux-x64_bin.tar.gz
</code></pre>

<h3 id="set-up-the-usrlibjvm-directory">Set up the /usr/lib/jvm directory</h3>

<ol>
  <li>
    <p>create the directory <code>/usr/lib/jvm</code></p>

    <pre><code> sudo mkdir -p /usr/lib/jvm
</code></pre>
  </li>
  <li>
    <p>If you already have directory named <code>/usr/lib/jvm/jdk-9.0.1</code>, move it out of the way:</p>

    <pre><code> sudo mv /usr/lib/jvm/jdk-9.0.1{,.orig}
</code></pre>
  </li>
  <li>
    <p>Move your newly unpacked jdk directory to <code>/usr/lib/jvm</code> then give it the alias <code>jdk1.9.0</code>:</p>

    <pre><code> sudo mv ~/opt/Java/jdk-9.0.1 /usr/lib/jvm/
 sudo ln -s /usr/lib/jvm/jdk{-9.0.1,1.9.0}
</code></pre>
  </li>
</ol>

<h3 id="make-jdk190-the-default-java-on-your-system">Make jdk1.9.0 the default Java on your system</h3>

<p>Use the <code>update-alternatives</code> program to configure multiple versions of Java
on the same machine. (For more details see: <a href="http://askubuntu.com/questions/55848/how-do-i-install-oracle-java-jdk-7">notes on configuring JDK 1.7 on Ubuntu</a>):</p>

<p>This first block of 9 commands can be copy-and-pasted to the command line all at once:</p>

<pre><code>    sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.9.0/bin/java" 1;
    sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk1.9.0/bin/javac" 1;
    sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk1.9.0/bin/javaws" 1;
    sudo update-alternatives --install "/usr/bin/jcontrol" "jcontrol" "/usr/lib/jvm/jdk1.9.0/bin/jcontrol" 1;
    sudo chmod a+x /usr/bin/java;
    sudo chmod a+x /usr/bin/javac;
    sudo chmod a+x /usr/bin/javaws;
    sudo chmod a+x /usr/bin/jcontrol;
    sudo chown -R root:root /usr/lib/jvm/jdk1.9.0;
</code></pre>

<p>The following commands are interactive and should be invoked individually:</p>

<pre><code>    sudo update-alternatives --config java
  
    sudo update-alternatives --config javac
  
    sudo update-alternatives --config javaws
  
    sudo update-alternatives --config jcontrol
</code></pre>

<p>Check which version of Java your system is currently using with the command <code>java -version</code>.</p>

<p>Finally, if you have other versions of Java installed on your system, you should make them
available using the <code>update-alternatives</code> program by following the same steps as we did above
for jdk version 9.0.1.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Commutator as Least Fixed Point]]></title>
    <link href="http://williamdemeo.github.io/2017/04/07/commutator-as-least-fixed-point/"/>
    <updated>2017-04-07T04:45:45-06:00</updated>
    <id>http://williamdemeo.github.io/2017/04/07/commutator-as-least-fixed-point</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/williamdemeo/alt-comm">alt-comm repository</a>
contains a note giving an alternate decription of the (non-modular) commutator that yields
a polynomial time algorithm for computing it. This is inspired by 
the alternate description of the commutator given 
by Kearnes in <a href="http://dx.doi.org/10.1006/jabr.1995.1334">[1]</a>.</p>

<!-- more -->

<p>[1] Keith Kearnes.
<a href="http://dx.doi.org/10.1006/jabr.1995.1334">Varieties with a difference term</a>.
<em>J. Algebra</em>, 177(3):926–960, 1995.</p>

<p>[[1]]: http://dx.doi.org/10.1006/jabr.1995.1334</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Conferences in Algebra]]></title>
    <link href="http://williamdemeo.github.io/2017/04/07/conferences-in-algebra/"/>
    <updated>2017-04-07T01:44:46-06:00</updated>
    <id>http://williamdemeo.github.io/2017/04/07/conferences-in-algebra</id>
    <content type="html"><![CDATA[<p>I started a GitHub repository called <a href="https://github.com/UniversalAlgebra/Conferences">UniversalAlgebra/Conferences</a> in an effort to 
keep up with the vast number of meetings in these areas and help make 
summer travel plans accordingly.</p>

<p>The <a href="https://github.com/UniversalAlgebra/Conferences">UniversalAlgebra/Conferences</a> repository is simply a list of links to the conferences 
listed.</p>

<!-- more -->

<p>Here are some other more general conference listings that may be updated more frequently than mine:</p>

<ul>
  <li><a href="http://www.wikicfp.com/cfp/">WikiCFP</a> A wiki for calls for papers.  </li>
  <li><a href="http://spot.colorado.edu/~kearnes/conf.html">General Algebra Conferences</a></li>
  <li><a href="http://www.conference-service.com/conferences/algebra.html">COMS: Algebra</a></li>
  <li><a href="http://www.conference-service.com/conferences/logic.html">COMS: Mathematical Logic</a></li>
  <li><a href="http://www2.informatik.hu-berlin.de/~lics/logic-confs/index.html">Logic Related Conferences</a></li>
  <li><a href="http://cstheory.stackexchange.com/questions/7900/list-of-tcs-conferences-and-workshops">A list of conferences in theoretical computer science</a>  </li>
  <li><a href="https://googledrive.com/host/0BxA1GnxVACojZWEtY0NCMzhSbjg/noteworthy.html">Peter Jipsen’s List</a></li>
  <li><a href="http://portal.core.edu.au/conf-ranks/">Conference rankings</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Congruences of Partial Algebras]]></title>
    <link href="http://williamdemeo.github.io/2017/04/07/congruences-of-partial-algebras/"/>
    <updated>2017-04-07T01:08:13-06:00</updated>
    <id>http://williamdemeo.github.io/2017/04/07/congruences-of-partial-algebras</id>
    <content type="html"><![CDATA[<p>The repository <a href="https://github.com/UniversalAlgebra/par-alg-rep">par-alg-rep</a>
contains some notes describing a few results that we worked out in the 
fall of 2016, while I was a postdoc at University of 
Hawaii, although the main result—a straight-forward proof of the fact 
that every finite lattice is the congruence lattice of a 
finite partial algebra—was discovered during a
visit to Chapman University in October 2016.</p>

<!-- more  -->

<p>Bill Lampe pointed out that the main result here has been known for 
a long time. However, our proof seems new and simpler to us.</p>

<p>The note also describes closure operators and reviews some useful 
facts about them. Finally, we recall a theorem from Berman’s 
thesis that relates congruence lattices of partial algebras 
with those of total algebras.</p>

<p>The main purpose of the note is to describe some tools 
that we plan to exploit in our quest to represent every finite 
lattice as the congruence lattice of a finite algebra.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3-SAT and partition lattices]]></title>
    <link href="http://williamdemeo.github.io/2015/01/11/three-sat-and-partition-lattices/"/>
    <updated>2015-01-11T20:53:17-07:00</updated>
    <id>http://williamdemeo.github.io/2015/01/11/three-sat-and-partition-lattices</id>
    <content type="html"><![CDATA[<p>It is not hard to see that <a href="https://en.wikipedia.org/wiki/3sat">3-SAT</a>
reduces to the problem of deciding whether all coatoms in a certain partition
lattice are contained in the union of a collection of certain principal filters.
Therefore, the latter problem, which we will call the
<em>covered coatoms problem</em> (CCP), is NP-complete.
In this post we simply define CCP. Later we check that 3-SAT reduces to CCP,
and then develop some ideas about constructing a feasible algorithm to solve CCP.</p>

<!-- more -->

<p>Consider the relational structure $\mathbf B = \langle \{0, 1\}, R\rangle$
where $R$ is the ternary relation $\{0, 1\}^3 - \{(0,0,0), (1,1,1)\}$.
That is,</p>

<script type="math/tex; mode=display"> R = \{(0,0,1), (0,1,0), (0,1,1), (1,0,0), (1,0,1), (1,1,0)\}.</script>

<p>We now describe the constraint satisfaction problem $\operatorname{CSP}(\mathbf B)$.</p>

<p>By an “instance” of $\operatorname{CSP}(\mathbf B)$, we mean
a (finite) relational structure $\mathbf A = \langle A, S \rangle$
with a single ternary relation $S$.</p>

<p>The <em>constraint satisfaction problem</em> $\operatorname{CSP}(\mathbf B)$ is the
following:</p>

<p>Given an instance $\mathbf A = \langle A, S \rangle$,
does there exist a relational homomorphism from $\mathbf A$ to $\mathbf B$?
That is, does there exist a function
$f: A \rightarrow \{0,1\}$ such that $(f(a), f(b), f(c)) \in R$ whenever
$(a, b, c) \in S$?</p>

<p>The kernel of a function $f$ with codomain $\{0,1\}$ has two equivalence
classes, or “blocks”—namely,
$f^{-1}\{0\}$ <!-- (the "0-block") -->
and $f^{-1}\{1\}$. <!-- (the "1-block") --></p>

<p>If one of these classes is empty, then $f$ is constant 
in which case it cannot be a homomorphism into the relational structure
$\langle \{0, 1\}, R\rangle$ (since $(0,0,0)\notin R$ and $(1,1,1)\notin R$).</p>

<p>Therefore, the kernel of every homomorphism $f : \mathbf A \rightarrow \mathbf B$
has two nonempty blocks.</p>

<p>Now, given a partition of $A$ into two blocks, $\pi = |A_1|A_2|$,
there are exactly two functions of type $A \rightarrow \{0,1\}$
with kernel $\pi$. One is $f(x) = 0$ iff $x \in A_1$ and the other is $1-f$.
It is obvious that either both $f$ and $1-f$ are homomorphisms or neither $f$
nor $1-f$ is a homomorphism. </p>

<p>Indeed, both are homomorphisms if and only if
for all tuples $(a,b,c) \in S$ we have $\{a,b,c\} \nsubseteq A_1$ and
$\{a,b,c\} \nsubseteq A_2$.</p>

<p>Neither is a homomorphism if and only if there exists
$(a,b,c) \in S$ with $\{a,b,c\} \subseteq A_1$ or
$\{a,b,c\} \subseteq A_2$.</p>

<!-- Now, for each tuple $s = (a,b,c) \in S$, we let $\\{s\\}$ denote the *set* -->
<!-- generated by $a$, $b$, and $c$ (so $1\leq |\\{s\\}| \leq 3$) and -->
<!-- let $\langle s\rangle$ denote the equivalence relation of $A$ generated by $\\{s\\}$. -->

<p>Now, for each tuple $s = (a,b,c) \in S$, we let
$\langle s\rangle$ denote the equivalence relation of $A$ generated by
$a$, $b$, and $c$. 
<!-- (Note that $a$, $b$, and $c$ need not be distinct, so  -->
<!-- the set they generate may have fewer than 3 elements.) -->
<!-- $$\langle s\rangle = \{(a,b), (b,a), (a,c), (c,a), (b,c), (c,b)\} \cup \{(x,x) : x \in A\}.$$ -->
<!-- The partition corresponding to $\langle s \rangle$ is $$\pi_{\langle s\rangle} = |a, b, c|x\_1|x\_2|\cdots.$$ -->
It is clear that a function $f: A \rightarrow \{0, 1\}$ is a homomorphism from
$\mathbf A$ to $\mathbf B$ if and only if for all $s \in S$
the relation $\langle s\rangle$ does not belong to the kernel of $f$.
Therefore, a solution to the instance $\mathbf A = \langle A, S \rangle$ of
$\operatorname{CSP}(\mathbf B)$ exists if and only if there is at least one coatom
in the lattice of equivalence relations of $A$ that is not contained in the union
$ \bigcup_{s\in S} \, ^\uparrow\langle s \rangle $ of principal filters.</p>

<p>The <strong>Covered Coatoms Problem</strong> is the following: Given a set $A$ and a list
$s_1 = (a_1, b_1, c_1), s_2=(a_2, b_2, c_2), \dots, s_n =(a_n, b_n, c_n)$
of 3-tuples with elements drawn from $A$, decide whether all of the coatoms
of the lattice $\prod_A$ of partitions of $A$ are contained in the union
$ \bigcup_{i=1}^n \, ^\uparrow\langle s_i \rangle $ of principal filters.</p>

<p>If we find an algorithm that decides this in polynomial time (in the size
of the set $A$), or if we prove that no such algorithm exists, then this
would answer the P versus NP question.</p>

<!-- Therefore, we see that determining whether an instance of -->
<!-- $\operatorname{CSP}(\mathbf B)$ has a solution is equivalent to -->
<!-- determining whether  -->
<!-- Let $n = |A| > 0$. &#8211;>
<!-- For each tuple $(a,b,c) \in S$, consider  -->
<!-- Determining whether there exists a solution to a given instance of -->
<!--  $\operatorname{CSP}(\mathbf B)$ is equivalent to deciding  -->
<!-- We will show that any instance of 3-SAT can be reduced to an instance of -->
<!--  $\operatorname{CSP}(\mathbf B)$.  Then  -->
<!-- is the -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jane Street Test]]></title>
    <link href="http://williamdemeo.github.io/2014/03/19/probability-quiz/"/>
    <updated>2014-03-19T18:27:46-06:00</updated>
    <id>http://williamdemeo.github.io/2014/03/19/probability-quiz</id>
    <content type="html"><![CDATA[<p>The questions below appeared on an online test administered by 
Jane Street Capital Management to assess whether a person is worthy of 
a phone interview.</p>

<!-- more -->

<h3 id="question-1">Question 1</h3>
<p>Suppose we choose four numbers at random without replacement from the first
20 prime numbers. What is the probability that the sum of these four numbers is odd?</p>

<p><strong>Solution</strong> By definition, an <em>even</em> number is an integer multiple of 2; that
is, even numbers have the form $2n$, for some integer $n$. An <em>odd</em> number is
one more than an even number; that is, odd numbers have the form $2n+1$ for
some integer $n$. </p>

<p>If all four numbers are odd, then the sum is even.  This follows
from the fact that the sum of two odd numbers is even: $(2n+1) + (2k+1) =
2(n+k) + 2 = 2(n+k+1)$.  And the sum of two even numbers is again even: $2n+2k =
2(n+k)$.  Therefore, in order for the sum of the four primes chosen to
be odd, the only even prime number, 2, must be among the four numbers we
selected.</p>

<p>Here are two ways to compute the probability that 2 is one of the four numbers selected:
First, consider the probability of <em>not</em> selecting 2:
$$
P(\text{2 is not among the chosen primes}) = 
\frac{19}{20}
\frac{18}{19}
\frac{17}{18}
\frac{16}{17}
=
\frac{16}{20}
=
\frac{4}{5}.
$$</p>

<p>Then the probability that 2 is among the four chosen prime numbers is 
$1 - \frac{4}{5}$, or $\frac{1}{5}$.</p>

<p>Alternatively, we could count the number of four-tuples that have a 2.  This is
the same as taking 4 times the number of ways to choose the other three numbers: 
$19\cdot 18\cdot 17$. (The factor of 4 appears since we could put the 2 in any of four
positions).  Now divide this by the total number of four-tuples, 
$20 \cdot 19\cdot 18\cdot 17$, to arrive at the same answer as above:</p>

<script type="math/tex; mode=display">
\frac{4\cdot 19\cdot 18\cdot 17}
{20 \cdot 19\cdot 18\cdot 17} = 
\frac{4}{20} = \frac{1}{5}.
</script>

<h3 id="question-2">Question 2</h3>
<p>Suppose you have an 8 sided die with sides labeled 1 to 8.  You roll the die
once and observe the number $f$ showing on the first roll.  Then you have the
option of rolling a second time.  If you decline the option to roll again, you win
$f$ dollars. If instead you exercise the option to roll a second time, 
and if $s$ shows on the second roll, then you win $f + s$ dollars if $f+s &lt; 10$ 
and 0 dollars if $f+s \geq 10$.  What is the best strategy?</p>

<p><strong>Solution</strong> </p>

<p>A strategy is given by specifying what to do in response to 
each possible first roll, $f$. The best strategy will maximize the expected winnings.</p>

<p>The expected winnings if we roll just once is simply the number that appears, $f$.</p>

<p>Let $S$ be the random variable representing the value showing on the second
roll. This is uniformly distributed with $P(S=s) = 1/8$.
Therefore, if we observe $f$ and then decide to roll twice, the expected
winnings are</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

  E(W | f, \mathrm{roll\ twice}) = \sum_{s=1}^8 (f+s)\chi_{\{f+s < 10\}} P(S=s)
  = \frac{1}{8}\sum_{s=1}^8 (f+s)\chi_{\{f+s < 10\}}
 %]]&gt;</script>

<p>where $\chi$ denotes the characteristic function, that is,
$\chi_{\mathrm{True}}=1$ and $\chi_{\mathrm{False}}=0$.</p>

<p>If we let $N= \min{8, 10 - f -1}$, then the expected value of rolling twice is</p>

<script type="math/tex; mode=display">
E(W | f, \mathrm{roll\ twice}) = \frac{1}{8}\sum_{s=1}^{N} (f+s)
</script>

<p>If we observe $f=1$ on the first roll, then </p>

<script type="math/tex; mode=display">
E(W | f=1, \mathrm{roll\ twice})  = \frac{1}{8} \sum_{s=1}^8 (1+s)= \frac{11}{2}.
</script>

<p>Since this is greater than 1, we should certainly exercise the option to roll
twice if 1 shows up on the first roll.</p>

<p>Continuing this way, we have</p>

<script type="math/tex; mode=display">
E(W | f=2, \mathrm{roll\ twice}) =  \frac{1}{8}\sum_{s=1}^{7} (2+s)
=  \frac{1}{8}(2\cdot7 + 1 + 2+ 3+ \cdots + 7)
= 6.
</script>

<script type="math/tex; mode=display">
E(W | f=3, \mathrm{roll\ twice}) =\frac{1}{8}\sum_{s=1}^{6} (3+s)
= \frac{1}{8}(3\cdot 6 +1 + 2+ 3+ \cdots + 6)
= \frac{39}{8}.
</script>

<script type="math/tex; mode=display">
E(W | f=4, \mathrm{roll\ twice}) = \frac{1}{8}\sum_{s=1}^{5} (4+s)
= \frac{1}{8}(4\cdot 5+1 + 2+ 3+ \cdots + 5)
= \frac{35}{8}.
</script>

<p>Since this is larger than 4, we should roll twice when observing 4 on the first roll.</p>

<p>However, if $f = 5$, then </p>

<script type="math/tex; mode=display">
E(W | f=5, \mathrm{roll\ twice}) = \frac{1}{8}\sum_{s=1}^{4} (5+s)
= \frac{1}{8}((5)(4)+1 + 2+ 3+ \cdots + 4)
= \frac{30}{8}.
</script>

<p>Since this is <em>less</em> than 5, we should <em>not</em> roll a second time when a 5 is observed
on the first roll.</p>

<p><strong>General strategy:</strong> Exercise the option to roll a second time if the first
results in 1, 2, 3, or 4.  Otherwise, decline the second roll and take the value
shown on the first roll. </p>

<hr />

<h3 id="question-3">Question 3</h3>

<p>(The original question was for 3 coins, with respective probabilities 0.5, 0.3, and
0.2 of coming up heads.  This version is a generalization to $n$ coins with
arbitrary probabilities that sum to 1.)</p>

<p>Suppose you have a bag with $n$ coins, $C_1, C_2, \dots, C_n$,  and coin
$C_i$ has probability $p_i$ of coming up heads when flipped.  Assume 
$p_1 + p_2 + \cdots p_n = 1$.  Suppose you draw a coin from the bag at random
and flip it and it comes up heads.  If you flip
the same coin it again, what is the probability it comes up heads?</p>

<p>Denote by $H_i$ the event that heads turns up on the $i$-th flip, and by a
slight abuse of notation, let $C_i$ denote the event that we are flipping coin $C_i$.
Then </p>

<script type="math/tex; mode=display">
P(H_2 | H_1) = \sum_{i=1}^n P(H_2| C_i, H_1) P(C_i|H_1)
= \sum_{i=1}^n p_i P(C_i|H_1)
</script>

<p>Applying Bayes’ Theorem,</p>

<script type="math/tex; mode=display">
P(C_i|H_1) = \frac{P(C_i,H_1)}{P(H_1)} = 
\frac{P(H_1|C_i) P(C_i)}{P(H_1)}.
</script>

<p>Assuming all coins are equally likely to have been drawn from the bag,
$P(C_i)=\frac{1}{n}$. Therefore,</p>

<script type="math/tex; mode=display">
P(H_1) = \sum_{i=1}^n P(H_1| C_i) P(C_i) = \frac{1}{n}\sum_{i=1}^n p_i =
\frac{1}{n},
</script>

<p>whence,</p>

<script type="math/tex; mode=display">
P(C_i|H_1) = \frac{P(H_1|C_i) P(C_i)}{P(H_1)} = p_i \frac{1/n}{1/n} = p_i.
</script>

<p>Therefore,</p>

<script type="math/tex; mode=display">
P(H_2 | H_1) = \sum_{i=1}^n p_i^2.
</script>

<p>For the special case given in the original problem, we have</p>

<script type="math/tex; mode=display">
P(H_2 | H_1) = (0.5)^2 + (0.3)^2 + (0.2)^2 = 0.25 + 0.09 + 0.04 = 0.38.
</script>

<hr />

<h3 id="question-4">Question 4</h3>

<p>Suppose you have two urns that are indistinguishable from the outside.
One of the urns contains 3 one-dollar coins and 7 ten-dollar coins.
The other urn contains 5 one-dollar coins and 5 ten-dollar coins.
Suppose you choose an urn at random and draw a coin from it at random.<br />
You find that it is a $10 coin.  Now you are given the option to draw 
again (without replacing the first coin) from either the same urn or 
the other urn.  Should you draw from the same urn or switch?</p>

<p><strong>Solution</strong></p>

<p>The problem is uninteresting if we assume the draws are made with replacement.
Clearly we should not switch urns in this case.  Assume the second draw is made
without replacing the first coin.</p>

<p>Let $X$ be a random variable denoting the value of the second draw.  We
compute the expected values $E(X | \text{ stay})$ and $E(X | \text{ switch})$
and whichever is higher determines our strategy.</p>

<p>Let us call the urn that starts with 7 ten-dollar coins urn $A$,
and the urn that starts with 5 ten-dollar coins urn $B$.
Let $A_1$ denote the event that urn $A$ is chosen for the first draw and let
$B_1$ denote the event that urn $B$ is chosen for the first draw.
Let $T$ denote the event that the first draw produces a ten-dollar coin.  </p>

<p>The probability that a ten-dollar coin appears on the first draw is</p>

<script type="math/tex; mode=display">
P(T) = P(T| A_1) P(A_1)+ P(T| B_1) P(B_1) = \frac{7}{10}\frac{1}{2} +\frac{5}{10}\frac{1}{2} = \frac{3}{5}.
</script>

<p>Given that $T$ occurred, the probability we were drawing from $A$ is, by Bayes’ Theorem,</p>

<script type="math/tex; mode=display">
P(A_1 | T) = \frac{P(T|A_1) P(A_1)}{P(T)} = \frac{(7/10)(1/2)}{3/5} = \frac{7}{12}.
</script>

<p>Similarly the probability we were drawing from $B$, given $T$, is</p>

<script type="math/tex; mode=display">
P(B_1 | T) = \frac{P(T|B_1) P(B_1)}{P(T)} = \frac{(5/10)(1/2)}{3/5} = \frac{5}{12}.
</script>

<p>Now, if we decide to draw again from the same urn and that urn happens to be
$A$, there will be 6 ten-dollar coins remaining, so our expected value of
drawing again from $A$ is</p>

<script type="math/tex; mode=display">
E(X | A_1, \text{ same}) = 10\cdot \frac{6}{9} + 1 \cdot \frac{3}{9} =
\frac{21}{3} = 7.
</script>

<p>If we decide to draw from the same urn and it happens to be $B$,
there will be 4 ten-dollar coins remaining, so </p>

<script type="math/tex; mode=display">
E(X | B_1, \text{ same}) = 10\cdot \frac{4}{9} + 1 \cdot \frac{5}{9} =
\frac{45}{9} = 5.
</script>

<p>So, if we don’t switch urns, the expected value of the second draw is</p>

<script type="math/tex; mode=display">
E(X | \text{ same}) 
= E(X | A_1, \text{ same}) P(A_1)
+ E(X | B_1, \text{ same}) P(B_1) = \frac{7\cdot 7}{12} +
\frac{5 \cdot 5}{12} =  6.16.
</script>

<p>Suppose instead we decided to switch urns. In the event $A_1$ that the
first draw was from urn $A$, then urn $B$ will contain its original contents:
5 ten-dollar coins and 5 one-dollar coins. Therefore,</p>

<script type="math/tex; mode=display">
E(X | A_1, \text{ switch}) = 10\cdot \frac{5}{10} + 1 \cdot \frac{5}{10} = 6.5.
</script>

<p>If we switch in the event $B_1$, then we choose from a
pristine urn $A$ having 7 ten-dollar coins and 3 one-dollar coins. Thus,</p>

<script type="math/tex; mode=display">
E(X | B_1, \text{ switch}) = 10\cdot \frac{7}{10} + 1 \cdot \frac{3}{10} =
7.3.
</script>

<p>Therefore,</p>

<script type="math/tex; mode=display">
E(X | \text{ switch}) 
= E(X | A\_1, \text{ switch}) P(A\_1)+ E(X | B\_1, \text{ switch}) P(B\_1) = 6.5 \frac{7}{12} + 7.3 \frac{5}{12}.
</script>

<p>So, the expected value of the second draw if we switch urns is a little more
than 6.83.</p>

<p><strong>Conclusion:</strong> The best strategy is to switch urns before drawing the second coin.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn You an Agda]]></title>
    <link href="http://williamdemeo.github.io/2014/02/27/learn-you-an-agda/"/>
    <updated>2014-02-27T00:00:00-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/27/learn-you-an-agda</id>
    <content type="html"><![CDATA[<p>This is a markdown version of the tutorial
<a href="http://learnyouanagda.liamoc.net/">Learn You an Agda and Achieve Enlightenment!</a>
by <a href="http://liamoc.net/">Liam O’Connor-Davis</a>.  </p>

<p>I made this version for my own reference, while working through the
tutorial, making some revisions and additions, and a few
corrections.  You may prefer
<a href="http://learnyouanagda.liamoc.net/">the original</a>.</p>

<!-- more -->
<p>$\def\N{\mathbb N} \def\true{\mathsf{true}} \def\conj{\wedge} \def\disj{\vee}$
<img src="http://williamdemeo.github.io/images/cover.png" /></p>

<hr />

<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#introduction">1. Introduction</a>
    <ul>
      <li><a href="#about-this-tutorial">About this tutorial</a></li>
      <li><a href="#step-one-learn-haskell">Step One: Learn Haskell</a></li>
      <li><a href="#what-is-agda-anyway">What is Agda, anyway?</a>
        <ul>
          <li><a href="#programs-are-proofs">Programs are Proofs</a></li>
          <li><a href="#why-prove-when-you-can-just-test">Why prove when you can just test?</a></li>
        </ul>
      </li>
      <li><a href="#how-do-i-get-started">How do I get started?</a>
        <ul>
          <li><a href="#installing-agda-the-new-way">Installing Agda: the new way</a></li>
          <li><a href="#installing-agda-the-old-way">Installing Agda: the old way</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#hello-peano">2. Hello, Peano</a>
    <ul>
      <li><a href="#definitions-definitions">Definitions, Definitions</a>
        <ul>
          <li><a href="#hold-on-a-second-types-have-types">Hold on a second, types have types?</a></li>
          <li><a href="#structural-induction">Structural Induction</a></li>
          <li><a href="#aside-haskell">Aside: Haskell</a></li>
        </ul>
      </li>
      <li><a href="#one-two-five!">One, Two, …Five!</a>
        <ul>
          <li><a href="#aside-what-do-those-underscores-mean">Aside: What do those underscores mean?</a></li>
        </ul>
      </li>
      <li><a href="#our-first-check">Our First Check</a>
        <ul>
          <li><a href="#i-have-merely-proven-it-correct">“I Have Merely Proven It Correct”</a></li>
          <li><a href="#troubleshooting">Troubleshooting</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#propositions-and-predicates">3. Propositions and Predicates</a>
    <ul>
      <li><a href="#logic-is-the-art-of-going-wrong-with-confidence">“Logic is the art of going wrong with confidence”</a></li>
      <li><a href="#how-does-it-all-relate-to-agda">How does it all relate to Agda?</a>
        <ul>
          <li><a href="#four-is-an-even-number">Four is an even number</a></li>
          <li><a href="#implicits">Implicits</a></li>
          <li><a href="#implication">Implication</a></li>
          <li><a href="#universal-quantification">Universal Quantification</a></li>
          <li><a href="#conjunction">Conjunction</a></li>
          <li><a href="#bijection">Bijection</a></li>
          <li><a href="#proving-conjunction-properties">Proving conjunction properties</a></li>
          <li><a href="#disjunction">Disjunction</a></li>
          <li><a href="#negation">Negation</a></li>
        </ul>
      </li>
      <li><a href="#the-curry-howard-correspondence">The Curry Howard Correspondence</a></li>
    </ul>
  </li>
  <li><a href="#hole-filling">4. Hole filling</a></li>
  <li><a href="#notes">Notes</a>  </li>
  <li><a href="#copyright">Copyright</a></li>
</ul>

<p><a href="#copyright">Copyright (c) 2013, Liam O’Connor-Davis</a></p>

<hr />

<h1 id="introduction">Introduction</h1>

<h2 id="about-this-tutorial">About this tutorial</h2>

<p>Welcome to <em>Learn You an Agda and Achieve Enlightenment!</em>
If you’re reading this, you’re probably curious as to what Agda is, why you want
to learn it, and in general what the big deal is about dependently typed, purely
functional programming.</p>

<p>Inspired by BONUS, the writer of
<a href="http://learnyouahaskell.com">Learn You a Haskell</a>, I decided
that I should write an approachable Agda tutorial that would introduce dependently typed
programming to ordinary people rather than Ivory Tower Academics. Of course, seeing as
<em>I</em> am one of those Ivory Tower Academics, this might not be easy. I am, however, prepared
to give it a try. Learning Agda was a very rewarding but very difficult process for me. It
is my hope that, by writing this tutorial, it will become a little bit easier for everyone
else.</p>

<hr />

<h2 id="step-one-learn-haskell">Step One: Learn Haskell</h2>

<p>(The original tutorial suggested that Haskell should be learned before Agda.
However, if one already knows some functional programming, then
Agda should not be very hard to learn. This should be especially true for those
with some background in logic and experience with other dependently typed languages.)</p>

<div class="span3">
<img src="http://williamdemeo.github.io/images/koala.png" />
</div>

<p>This tutorial is not aimed at those who are completely new to functional
programming. Agda is similar on a basic level to typed functional languages such
as Haskell and ML, and so knowing a language in the ML family will certainly
make learning Agda a great deal easier. </p>

<p>If you don’t know a statically typed functional language, I recommend that you
learn Haskell, as Agda has a close relationship with the Haskell ecosystem. If
you’re looking for a good Haskell tutorial, look no further than this book’s
companion, <a href="http://learnyouahaskell.com">Learn You a Haskell</a>. </p>

<p>If you don’t know how purely functional programming works, learn a little of it before 
trying to tackle Agda.</p>

<p>Understanding of imperative and object oriented programming (C, Java, Ruby..) isn’t
necessary. In fact, trying to apply skills learned from these languages might even be
harmful when you’re trying to learn Agda.</p>

<p>The moral of the story is: keep an open mind. A lot of Agda’s power comes from features 
that are at first difficult to understand. It took a long time for everything in Agda 
to fall into place in my head. Agda is <em>hard</em>. After some time, though, Agda’s inherent
awesomeness comes to the fore, and it all just clicks. If you encounter 
obstacles in your Agda learning, don’t be discouraged! Keep working, and eventually 
you will be a master of Agda fu.</p>

<hr />

<h2 id="what-is-agda-anyway">What is Agda, anyway?</h2>

<p>Agda is a programming language, but not a programming language like Java. It’s not 
even very much like Haskell, although it’s a lot more like Haskell than Java. </p>

<p>Agda is a programming language that uses <em>dependent types</em>. Many of you would
be familiar with types from imperative languages such as Java or C++, and if you’re
reading up to this point, you should also have a familiarity with types from
Haskell.</p>

<p>Types in these languages essentially annotate expressions with a tag. At a simple level,
an expression’s type might just be a concrete type, like <code>Bool</code> or <code>Int</code>. Java (through
generics), C++ (through templates) and Haskell all support polymorphic types as well,
such as <code>List a</code> or <code>Map k v</code>.</p>

<div class="span4">
<img src="http://williamdemeo.github.io/images/types.png" />
</div>

<p>But, if <code>List a</code> is a type, then what exactly <em>is</em> just <code>List</code> (without the parameter)? 
Haskell calls it a “type constructor”, but really it’s a <em>function</em> at the type
level. <code>List</code> takes in a type, say <code>Int</code>, and returns a new type, <code>List
Int</code>. Haskell (with appropriate extensions) even supports arbitrary functions on
the type level, that don’t necessarily have to construct a type term, and
instead can simply refer to existing ones. </p>

<p>So, Haskell has type-level functions, even type-level types (kinds). It almost seems like
an entirely new language, overlaid over Haskell, that operates at compile time,
manipulating type terms. </p>

<p>In fact, you could think of any type system this way. In C++, people exploit the
Turing-completeness of their type system to perform compile-time analysis and
computation. While such type level work is very powerful, I fear that such type
machinery is very often difficult to understand and manipulate. Even in Haskell,
applications that make extensive use of type-level computation are very often
substantially harder to comprehend. The type-level “language” is almost always
substantially more complicated to work with than the value-level “language.”</p>

<p>In Agda, the distinction between types and values does not exist. Instead, the
language you use to manipulate type terms is exactly the same language that you
use to manipulate values. </p>

<p>This means that you can actually include values <em>inside</em> a type. For example, the <code>List</code>
type constructor can be parameterized by both the type of its contents <em>and</em> the length of 
the list in question (we’ll be doing this later). This allows the compiler to check for you
to make sure there are no cases where you attempt to call <code>head</code> on a
potentially empty list, for example. Being able to include values inside a type,
and use all the same value-level operations on them, is what makes Agda
<em>dependently typed</em> - Not only can values have a type, but types can have a value.</p>

<p>In fact, seeing as the language of values and the language of types are the
same, <em>any property</em> that you can express about a value can be expressed
statically in its type, and machine checked by Agda. We can statically eliminate
any error scenario from our program.</p>

<hr />

<h3 id="programs-are-proofs">Programs are Proofs</h3>

<div class="span4">
<img src="http://williamdemeo.github.io/images/owl.png" />
</div>

<p>If I can come up with a function of type <code>Foo -&gt; Bar</code> (and Agda says that it’s
type correct) that means that I’ve written not only a program, but also a proof
by construction that, assuming some premise <code>Foo</code>, the judgment <code>Bar</code>
holds. (We’ll touch more on proofs later; I don’t want to get bogged down in
details just yet.)</p>

<p>Seeing as our <code>Foo</code> and <code>Bar</code> can be as expressive as we like, this lets us
prove <em>anything we want</em> about our program simply by exploiting this
correspondence between proofs and programs - called the
<a href="http://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard Correspondence</a>,
discovered by two brilliant logicians in the sixties.</p>

<hr />

<h3 id="why-prove-when-you-can-just-test">Why prove when you can just test?</h3>

<p>The validity of formal verification of software is often hotly contested by
programmers who usually have no experience in formal verification. Often testing
methodologies are presented as a more viable alternative.</p>

<p>While formal verification is excessive in some situations where bugs are
acceptable, I hardly think that testing could replace formal verification
completely. Here are three reasons for this:</p>

<ul>
  <li><strong>Proofs work in concurrent scenarios</strong>. You can’t reliably unit test against
 race conditions, starvation or deadlock. All of these things can be
 eliminated via formal methods.</li>
  <li><strong>Proofs, like programs, are compositional</strong>. Tests are not. In testing
scenarios, one typically has to write both unit tests and integration tests:
unit tests for testing small components individually, and integration tests
for testing the interaction between those small components. If I have proofs
of the behavior of those small components, I can simply use those proof
results to satisfy a proof obligation about their interaction – there is no
need to reinvent everything for both testing scenarios.</li>
  <li><strong>Proofs are fool-proof</strong>. If I have a suite of tests to show some property,
it’s possible that that property does not actually hold - I simply have not
been thorough enough in my tests. With formal verification, it’s impossible
for violations of your properties to slip through the cracks like that.</li>
</ul>

<p>Of course, proofs are not for every scenario, but I think they should be far
more widely used than they currently are.</p>

<p>Thanks to Curry-Howard, Agda can also be used as a <em>proof</em> language, as opposed
to a <em>programming</em> language. You can construct a proof not just about your
program, but about anything you like. </p>

<p>In fact, Curry-Howard shows us that the fundamentals of functional programming
(Lambda Calculus), and the fundamentals of mathematical proof (Logic) are in
fact the same thing (<em>isomorphic</em>). This means that we can structure
mathematical proofs in Agda as <em>programs</em>, and have Agda check them for us. It’s
just as valid as a standard pen-and-paper mathematical proof (probably more so,
seeing as Agda doesn’t let us leave anything as “an exercise for the reader” -
and Agda can check our proof’s correctness automatically for us. We’ll be doing
this later by proving some basic mathematical properties on Peano natural numbers.</p>

<p>So, Agda is a language that really lives the dream of the Curry-Howard
correspondence. An Agda program is also a proof of the formula represented in
its type.</p>

<hr />

<h2 id="how-do-i-get-started">How do I get started?</h2>

<p>At the time of writing, it is only really feasible to edit Agda code using
Emacs. GNU Emacs or XEmacs are both fine. However, you don’t need a great deal
of Emacs proficiency to edit Agda code. </p>

<h3 id="installing-agda">Installing Agda</h3>

<p>(If you are using Ubuntu Linux, you may wish to skip to the next section,
<a href="#installing-on-Ubuntu-Linux">Installing on Ubuntu Linux</a>.)</p>

<p>You’ll need GHC, a Haskell compiler, and an assortment of tools and libraries
that make up the <a href="http://hackage.haskell.org/platform/">Haskell Platform</a>. It is
the best way to get started using Haskell, and it’s also the easiest way to get Agda.</p>

<p>Once you have Haskell and Emacs, there are three things you still need to do:</p>

<ul>
  <li>Install Agda. Linux users may have Agda packages available from their package
manager (search for “agda” to find out). If not or otherwise, simply use the
Haskell platform’s <code>cabal-install</code> tool to download, compile, and set up Agda.</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre>$ cabal install agda
</pre></div>
</div>
</div>

<ul>
  <li>Install Agda mode for emacs. Simply type in a command prompt (where Agda is in
your <code>PATH</code>):</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre>$ agda-mode setup
</pre></div>
</div>
</div>

<ul>
  <li>Compile Agda mode as well (you’ll need to do this again if you update Agda):</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre>$ agda-mode compile
</pre></div>
</div>
</div>

<p>By then you should be all set. To find out if everything went as well as
expected, head on over to the <a href="#hello-peano">next section</a>.</p>

<h3 id="installing-on-ubuntu-linux">Installing on Ubuntu Linux</h3>

<p>On a Ubuntu Linux system, instead of installing Agda using cabal as above, one
could alternatively use the following two commands, which take a few minutes to run: </p>

<pre><code>sudo apt-get install agda-mode
sudo apt-get install agda-stdlib
</code></pre>

<p>That’s it!  Now, when you launch Emacs and edit a file with the .agda extension,
it should switch to <code>agda-mode</code> or <code>agda2-mode</code>. If not, you can switch manually
by invoking one of the following (in Emacs, of course): <code>M-x agda-mode</code> or 
<code>M-x agda2-mode</code> or <code>Esc-x agda-mode</code>.  (An easy way to find out which agda
modes are available is to type <code>M-x agda</code> and then hit tab a couple of times to
see the possible completions.)</p>

<hr />

<h1 id="hello-peano">Hello, Peano</h1>

<h2 id="definitions-definitions">Definitions, Definitions</h2>

<p>Unlike the previous section, this section will actually involve some coding in Agda.</p>

<p>Most language tutorials start with the typical “Hello, World” example, but this
is not really appropriate for a first example in Agda. Unlike other languages,
which rely on a whole lot of primitive operations and special cases for basic
constructs, Agda is very minimal - most of the “language constructs” are
actually defined in libraries. </p>

<p>Agda doesn’t even have numbers built in, so the first thing we’re going to do is
define them—specifically <em>natural numbers</em>. Natural numbers are nonnegative
integers, that is, the whole numbers starting with zero and going
up. Mathematics uses the symbol $\N$ to represent natural numbers, so we’re going
to borrow that for our example (Another thing that sets Agda apart from other
languages is its extensive use of unicode to make mathematical constructs  more
natural). To enter ℕ into emacs, type <code>\bn</code>. To enter the unicode arrow (→),
type <code>\-&gt;</code>.  I’m going to demonstrate this line by line, so bear with me.</p>

<p>First, open a file named <tt>LearnYouAn.agda</tt> in Emacs and type the following:</p>

<div><div class="CodeRay">
  <div class="code"><pre>module LearnYouAn where
  data ℕ : Set where
</pre></div>
</div>
</div>

<p>The <code>data</code> keyword means we’re defining a type—in this case, <code>ℕ</code>.
In this example, we’re specifying that the type <code>ℕ</code> is of type <code>Set</code> (that’s
what the colon means).</p>

<hr />

<h3 id="hold-on-a-second-types-have-types">Hold on a second, types have types?</h3>

<p>If you recall the introduction, I mentioned that in Agda, types and values are
treated the same way. Since values are given types, types
are given types as well. Types are merely a special group of language terms, and
in Agda, all terms have types. </p>

<p>Even <code>Set</code> (the type of our type <code>ℕ</code>) has a type: <code>Set₁</code>, which has a type
<code>Set₂</code>, going on all the way up to infinity. We’ll touch more on what these
<code>Set</code> types mean later, but for now you can think of <code>Set</code> as the type we give
to all the data types we use in our program. </p>

<p>This infinite hierarchy of types provides an elegant resolution of 
<a href="http://en.wikipedia.org/wiki/Russell's_paradox">Russell’s Paradox</a>.
For example, <code>Set₁</code> cannot contain <code>Set₁</code> or <code>Set₂</code>, only <code>Set</code>, so Russell’s
problematic set (that contains itself) cannot exist.</p>

<hr />

<h3 id="structural-induction">Structural Induction</h3>

<p>Okay, so, we’ve defined our type, but now we need to fill the type with
values. While a type with no values does have its uses, a natural numbers type
with no values is categorically wrong. So, the first natural number we’ll define
is zero: </p>

<div><div class="CodeRay">
  <div class="code"><pre>    zero : ℕ 
</pre></div>
</div>
</div>

<p>Here we are simply declaring the term <code>zero</code> to be a member of our new type
<code>ℕ</code>. We could continue to define more numbers this way: </p>

<div><div class="CodeRay">
  <div class="code"><pre>    zero : ℕ 
    one : ℕ
    two : ℕ
</pre></div>
</div>
</div>

<p>But we’d quickly find our text editor full of definitions and we’d be no closer
to defining all the natural numbers than when we started. So, we should instead
refer to a strict mathematical definition. </p>

<ul>
  <li>Zero is a natural number ($0\in\mathbb{N}$). </li>
  <li>For any natural number $n$, $n + 1$ is also a natural number. For convenience,
We shall refer to $n + 1$ as $\mathtt{suc}\ n.$<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
($\forall n \in \mathbb{N}.\ \mathtt{suc}\ n \in \mathbb{N}$).</li>
</ul>

<p>(The notation I’m using here should be
familiar to anyone who knows set theory and/or first-order logic.  Don’t panic
if you don’t know these things, we’ll be developing models for similar things in
Agda later, so you will be able to pick it up as we go along.)</p>

<p>This is called an <em>inductive definition</em> of natural numbers. We call it
<em>inductive</em> because it consists of a <em>base</em> rule, where we define a fixed
starting point, and an <em>inductive</em> rule that, when applied to an element of the
set, <em>induces</em> the next element of the set. This is a very elegant way to define
infinitely large sets. This way of defining natural numbers was developed by a
mathematician named Giuseppe Peano, and so they’re called the Peano numbers. </p>

<p>We will look at inductive <em>proof</em> in the coming sections, which shares a similar structure.</p>

<p>For the base case, we’ve already defined zero to be in $\mathbb{N}$ by saying:
<code>zero : ℕ</code>.  To define the natural numbers inductively, let’s recall the
induction step of first order logic.  This can be written as follows:</p>

<center>
   $\forall n \in \mathbb{N}.\ \mathtt{suc}\ n \in \mathbb{N}$
</center>

<p>Given a natural number <code>n</code>, the constructor <code>suc</code> will return
another natural number. In other words, <code>suc</code> could be considered a
<em>function</em> that, when given a natural number, produces the next natural
number. In Agda, we define the constructor <code>suc</code> like so: </p>

<div><div class="CodeRay">
  <div class="code"><pre>  data ℕ : Set where 
    zero : ℕ
    suc : ℕ → ℕ
</pre></div>
</div>
</div>

<p>Now we can express the number one as <code>suc zero</code>, and the number two as <code>suc (suc
zero)</code>, and the number three as <code>suc (suc (suc zero))</code>, and so on. </p>

<hr />

<h3 id="aside-haskell">Aside: Haskell</h3>
<p>Incidentally, this definition of natural numbers corresponds to the Haskell data type:</p>

<div><div class="CodeRay">
  <div class="code"><pre>data Nat = Zero | Suc Nat
</pre></div>
</div>
</div>

<p>If you load that into GHCi and ask it what the type of <code>Suc</code> is, it
(unsurprisingly) will tell you: <code>Nat -&gt; Nat</code>. This is a good way to get an
intuition for how to define constructors in Agda.</p>

<p>Also, GHC supports an extension, Generalized Algebraic Data Types or GADTs,
which allows you to define data types Agda style: </p>

<div><div class="CodeRay">
  <div class="code"><pre>data Nat :: * where
  Zero :: Nat
  Suc  :: Nat -&gt; Nat
</pre></div>
</div>
</div>

<p>It’s worth noting that GADTs are not exactly the same as Agda data definitions,
and Haskell is still not dependently typed, so much of what you learn in this
book won’t carry over directly to extended Haskell. </p>

<hr />

<h2 id="one-two-five">One, Two, …Five!</h2>

<p>Now we’re going to define some arithmetic operations on our natural
numbers. Let’s try addition, first. </p>

<div><div class="CodeRay">
  <div class="code"><pre>  _+_ : ℕ → ℕ → ℕ 
</pre></div>
</div>
</div>

<p>Here I’m declaring a function. To start with, I give it a type<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>—it takes
two natural numbers, and returns a natural number.</p>

<hr />

<h3 id="aside-what-do-those-underscores-mean">Aside: What do those underscores mean?</h3>

<p>Unlike Haskell which has only prefix functions (ordinary functions) and infix
functions (operators), Agda supports <em>mixfix</em> syntax. This allows you to declare
functions where the arguments can appear anywhere within a term. You use
underscores to refer to the “holes” where the arguments are meant to go. </p>

<p>So, an if-then-else construct in Agda can be declared with:<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<div><div class="CodeRay">
  <div class="code"><pre>  if_then_else_ : ∀ { a } → Bool → a → a → a
</pre></div>
</div>
</div>

<p>This can be used with great flexibility: You can call this function with <code>if a
then b else c</code>, which Agda interprets as <code>if_then_else_ a b c</code>. This syntactic
flexibility delivers great expressive power, but be careful about using it too
much, as it can get very confusing! </p>

<hr />

<h2 id="our-first-check">Our First Check</h2>

<p>Now, let’s implement and check the sum function by structural recursion.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>

<div><div class="CodeRay">
  <div class="code"><pre>  _+_ : ℕ → ℕ → ℕ
  zero + m = m
  (suc n) + m = suc (n + m)
</pre></div>
</div>
</div>

<p>Normally we’d run the program at this point to verify that it works, but in Agda
we <em>check</em> our code. This checks that all our <em>proof obligations</em> have been met:</p>

<ul>
  <li>It checks your types. Types are how you encode proofs in Agda (although we
haven’t done any non-trivial proofs yet), so this is important. </li>
  <li>It checks that your program provably terminates. </li>
</ul>

<p>Proof obligations of a program can only be machine-checked if the program
terminates, but checking that any program terminates is in general
undecidable (see <a href="http://en.wikipedia.org/wiki/Halting_problem">The Halting Problem</a>).
To circumvent this dilemma, Agda runs its checker only on <em>structural</em> recursion
with finite data structures, and warns that it can’t check proof obligations in
which non-structural recursion is used. We will discuss this more in later
sections, but all of the examples in the early part of this tutorial can
be proved by Agda to terminate.</p>

<p>At this point, the contents of the LearnYouAn.agda file should be as follows:</p>

<div><div class="CodeRay">
  <div class="code"><pre>module LearnYouAn where

  data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ

  _+_ : ℕ → ℕ → ℕ
  zero + m = m
  (suc n) + m = suc (n + m)
</pre></div>
</div>
</div>

<p>Make sure you get the indentation right!  In particular, the constructors
for <code>zero</code> and <code>suc</code> start in the 5th
column (below the t in <code>data</code>), whereas all three lines in the definition of
<code>_+_</code> begin in column 3.</p>

<p>To check the program, type <code>C-c C-l</code> in Emacs (or choose Load from the Agda
menu). If your program checks correctly, there will be no error messages, no hole markers
(yellow highlighting) and no orange-highlighted non-terminating sections. Also,
the words <code>(Agda: Checked)</code> should appear in the Emacs mode line, and you should
notice that the colors of characters have changed.</p>

<p>Right now, our checks aren’t all that meaningful—the only thing they prove is
that our addition function does indeed take any natural number and produce a
natural number, as the type suggests. Later on, when we encode more information
in our types, our checks can mean a lot more—even more than running and
testing the program. </p>

<hr />

<h3 id="i-have-merely-proven-it-correct">“I Have Merely Proven It Correct”</h3>

<p>To evaluate an expression (just to verify that it truly does work), we can type
<code>C-c C-n</code> into emacs, or select “Evaluate term to normal form” from the Agda
menu. Then, in the minibuffer, we can type an expression for 3 + 2:</p>

<pre><code>(suc (suc (suc zero))) + (suc (suc zero))
</code></pre>

<p>This produces the following representation of the number 5:</p>

<pre><code>(suc (suc (suc (suc (suc zero)))))
</code></pre>

<p>In this section we have examined the Peano natural numbers, and defined some
basic functions and data types in Agda. In the next section, we’ll look at
propositional logic, and how to encode logical proofs in Agda using this system.</p>

<hr />

<h3 id="troubleshooting">Troubleshooting</h3>
<p>If you are having trouble getting the First program to work, make sure you have
the indentation right.  It might help to download the
<a href="http://williamdemeo.github.io/downloads/code/agda/LearnYouAn.agda">LearnYouAn.agda</a> file, just to be sure.</p>

<hr />
<hr />

<h1 id="propositions-and-predicates">Propositions and Predicates</h1>

<h2 id="logic-is-the-art-of-going-wrong-with-confidence">“Logic is the art of going wrong with confidence”</h2>

<p>Now that we’ve defined the natural numbers, we’re going to do some simple
example proofs of some basic mathematical properties. We’ll first discuss logic
and logic specification in <em>natural deduction</em>, and as we go, we’ll discuss the
application to Agda. </p>

<p>At a fundamental level, a logic is a system of <em>judgments</em>. Judgments are
statements in a mathematical <em>language</em> that may be proven, or unproven. A
<em>language</em> is usually described as a set of strings, which make up every <em>term</em>
in the language, but this is a simplification: a language can be made up of
arbitrary data structures. We just use strings to represent these structures
because any data structure can be represented in some string form. </p>

<p>For our example, we will define a very simple logic based on the language of
<em>natural numbers</em> $\mathbb{N}$ we used earlier.</p>

<p>We’re going to have just one type of judgment, of the form $\mathbb{N}\
\textbf{even}$, which is provable only when the given number is even.</p>

<p>A logic consists of a set of <em>axioms</em> and a set of <em>rules</em>. Axioms are the
foundation of the logic: they’re the basic, simple statements that are assumed
to be true. <em>Rules</em> describe how to produce new <em>theorems</em> from existing ones.
A theorem is a proposition that has been proved. Thus, the rules tell us how to
construct proofs of statements using proofs of other statements.  We can
formally specify these axioms and rules in a <em>meta-logic</em> called <em>natural
deduction</em>, by writing them in the form of <em>inference rules</em>, which look like this: </p>

<script type="math/tex; mode=display">\frac{P_1 \quad P_2\quad\cdots\quad P_n}{C} \text{(name of rule)}</script>

<p>This says that if we can prove all of the <em>premises</em> $P_1 \cdots P_n$, then we
can prove the <em>conclusion</em> $C$.</p>

<p>For our purposes, we have just one axiom, that the number zero is even. Axioms
are written as inference rules with no premises:</p>

<script type="math/tex; mode=display">\frac{}{\mathtt{zero}\ \textbf{even}} {\rm Z\scriptsize ERO}</script>

<p>Then, based on the inductive reasoning we used earlier, the <em>rules</em> for our
logic should express that if some number $m$ is even, then $m + 2$ is also
even. We do this by writing an <em>inference rule schema</em>, which describes a <em>set</em> of
rules, by including one or more <em>metavariables</em> in an inference rule. </p>

<p>If we have some metavariable $x$ in a rule schema, we can substitute <em>any</em> term
in the language for $x$, and the result is a valid rule. For example,</p>

<script type="math/tex; mode=display">\frac{x\ \textbf{even}}{\mathtt{suc}\ (\mathtt{suc}\ x)\ \textbf{even}}
 {\rm S\scriptsize TEP}</script>

<p>If we want to show that four is even, we apply this rule twice
(once where $x$ is two, and once when $x$ is zero), leaving the obligation
$\mathtt{zero}\ \textbf{even}$ which is shown by the axiom ${\rm Z\scriptsize
ERO}$. </p>

<p>We can write this proof using natural deduction in a “proof tree” format:</p>

<script type="math/tex; mode=display"> \frac{\large \frac{\LARGE \frac{}{\mathtt{zero}\ \textbf{even}}{\rm\large Z\normalsize ERO}} {\mathtt{suc}\ (\mathtt{suc}\ \mathtt{zero})\ \textbf{even}}{\rm\small S\scriptsize TEP}} {\mathtt{suc}\ (\mathtt{suc}\ (\mathtt{suc}\ (\mathtt{suc}\ \mathtt{zero})))\ \textbf{even}} {\rm S\scriptsize TEP} </script>

<p>When proving a theorem, we work from the bottom of this tree upwards, applying
rules that fit the form of the goal as we go. When reading the proof, we work
downwards, reasoning from known axioms to the theorem that we want.</p>

<hr />

<h2 id="how-does-it-all-relate-to-agda">How does it all relate to Agda?</h2>

<p>Agda’s types correspond to judgments. If we can construct a value, or
“inhabitant,” of a certain type, we have simultaneously constructed a <em>proof</em>
that the theorem encoded by that type holds. </p>

<p>As types are judgments, and values are theorems, <em>data constructors</em> for a type
correspond to <em>inference rules</em> for the corresponding proposition. </p>

<p>Let’s encode the judgment $\textbf{even}$ in Agda, based on our definition in
natural deduction.
We’ll use the mix-fix name <code>_even</code> here rather than just <code>even</code> so that we can
use the judgment in post-fix form. As our judgment is over the language of
natural numbers, we <em>index</em> the type constructor for our judgment by the type <code>ℕ</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre>data _even : ℕ → Set where
</pre></div>
</div>
</div>

<p>Then we can define the axiom ${\rm Z\scriptsize ERO}$ as a
constructor for the type <code>zero even</code> as follows:</p>

<div><div class="CodeRay">
  <div class="code"><pre>   ZERO : zero even
</pre></div>
</div>
</div>

<p>The ${\rm S\scriptsize TEP}$ axiom is a little more complicated, due to
the presence of the metavariable $x$. If we just write the rule as-is,</p>

<div><div class="CodeRay">
  <div class="code"><pre>   STEP : x even → suc (suc x) even
</pre></div>
</div>
</div>

<p>Agda responds with the following:</p>

<pre><code>/home/username/LearnYouAn.agda:14,12-13
Not in scope:
  x
  at /home/username/LearnYouAn.agda:14,12-13
when scope checking x
</code></pre>

<p>To resolve this, we let <code>STEP</code> depend on a parameter, or variable.  We name
this variable $x$, and specify that $x$ must be of type ℕ, as follows:</p>

<div><div class="CodeRay">
  <div class="code"><pre>   STEP : (x : ℕ) → x even → suc (suc x) even
</pre></div>
</div>
</div>

<p>This is an example of a <em>dependent type</em>, which provides a means of defining a
<em>rule schema</em> (a collection of rules parameterized by a variable).
Here, for example, <code>STEP zero</code> refers to the rule <code>zero even → suc (suc zero) even</code>.
Thus <code>STEP</code> has the same substitution semantics for metavariables that we
described above.</p>

<p>At this point, our full program looks as follows:</p>

<div><div class="CodeRay">
  <div class="code"><pre>module LearnYouAn where

  data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ

  _+_ : ℕ → ℕ → ℕ
  zero + n = n
  (suc n) + m = suc (n + m)

  data _even : ℕ → Set where
    ZERO : zero even
    STEP : (x : ℕ) → x even → suc (suc x) even
</pre></div>
</div>
</div>

<p>You should type this program into your Emacs buffer, save it as the file
LearnYouAn.agda, and check it with <code>C-c C-l</code></p>

<p>Before we go on to use our program to actually prove something, we make
one more observation.  In the current version of our program, the type of <code>x</code>
can be inferred from its context, since we use it with <code>_even</code>, which takes a
instance of type <code>ℕ</code> as an argument.  Therefore, so we can use the special <code>∀</code>
symbol to introduce <code>x</code> and omit the type.  So, our final definition of <code>_even</code> is</p>

<div><div class="CodeRay">
  <div class="code"><pre>data _even : ℕ → Set where
   ZERO : zero even
   STEP : ∀ x → x even → suc (suc x) even
</pre></div>
</div>
</div>

<p>(This change will appear in the file
<a href="http://williamdemeo.github.io/downloads/code/agda/LearnYouAn2.agda">LearnYouAn2.agda</a> below.)</p>

<h3 id="four-is-an-even-number">Four is an even number</h3>

<p>Now we use our Agda program to prove that four is even. Add the following lines
to your LearnYouAn.agda file, and then type <code>C-c C-l</code> (use <code>\_1</code> to type the subscript symbol ₁):</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = ?
</pre></div>
</div>
</div>

<p>Agda will convert the question mark into the symbols <code>{ }0</code>, which is Agda’s
notation for a <em>hole</em> in the program (i.e., a hole in the proof).</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = { }0
</pre></div>
</div>
</div>

<p>The following will appear in a separate Emacs buffer:</p>

<pre><code>?0 : suc (suc (suc (suc zero))) even
</code></pre>

<p>This tells us that our proof obligation at hole <code>?0</code> is 
<code>suc (suc (suc (suc zero))) even</code>. </p>

<p>Next, put your cursor into the hole, and type <code>STEP ? ?</code>, and then type <code>C-c
C-space</code>. This splits the hole in two more holes. </p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = STEP { }1 { }2
</pre></div>
</div>
</div>

<pre><code>?1 : ℕ
?2 : suc (suc zero) even
</code></pre>

<p>The obligation <code>?1</code>, corresponding to hole <code>{ }1</code>, is the number we must provide
for <code>x</code> when applying the <code>STEP</code> constructor. <br />
Hole <code>{ }2</code> corresponds to proof obligation <code>?2</code>, which is the obligation to
show that two is even. In this case, there is only one constructor that fits
the obligation—namely, <code>STEP</code> </p>

<p>Move the cursor inside hole <code>{ }2</code> and type <code>C-c C-r</code>. Agda splits the hole
into another <code>STEP</code> call for us, resulting in two more holes, <code>{ }3</code> and <code>{ }4</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = STEP { }1 (STEP { }3 { }4)
</pre></div>
</div>
</div>

<pre><code>?1 : ℕ
?3 : ℕ
?4 : zero even
</code></pre>

<p>Another <code>C-c C-r</code> in hole <code>{ }4</code> will fill it with <code>ZERO</code>. </p>

<div><div class="CodeRay">
  <div class="code"><pre>  proof₁ : suc (suc (suc (suc zero))) even 
  proof₁ = STEP { } (STEP { } ZERO)
</pre></div>
</div>
</div>

<pre><code>?1 : ℕ
?3 : ℕ
</code></pre>

<p>The remaining obligations, <code>?1</code> and <code>?3</code>, can also be fulfilled automatically based
on the surrounding context. We can see what <em>constraints</em> on the holes are known
to Agda by using the “Show Constraints” option, or by typing 
<code>C-c C-=</code>. For the present example, this prints the following:</p>

<pre><code>?1 := suc (suc zero)
?3 := zero
</code></pre>

<p>Agda will fill in the holes for us if we use the “Solve Constraints” option, or
<code>C-c C-s</code>, and our final proof becomes</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = STEP (suc (suc zero)) (STEP zero ZERO)
</pre></div>
</div>
</div>

<p>Another feature worth mentioning is Agsy, an automatic proof searcher for
Agda. Simply type <code>C-c C-a</code> in any hole and Agsy will search for an appropriate
term to fill it. It’s not guaranteed to find anything, but it can be useful. 
(In the example above, it works well.)</p>

<h3 id="implicits">Implicits</h3>

<p>It can be annoying, though, to have to pass in those numbers to <code>STEP</code>
explicitly, when Agda already knows from surrounding context exactly what they
are. In these situations, you can use a single underscore (<code>_</code>) to indicate that
you wish Agda to infer the value in this position during type-checking.</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = STEP _ (STEP _ ZERO)
</pre></div>
</div>
</div>

<p>If Agda cannot infer the value of the implicit underscore, an “unsolved
metavariable” will be shown in the goals window, and the underscore will be
highlighted in yellow. </p>

<p>For this particular judgment, however, it is almost always obvious from known
constraints what the value of those numbers should be. In these cases, it’s
common to use an <em>implicit parameter</em> when declaring the type:</p>

<div><div class="CodeRay">
  <div class="code"><pre>data _even : ℕ → Set where
   ZERO : zero even
   STEP : ∀ {x} → x even → suc (suc x) even    -- long form { x : ℕ } is also fine
</pre></div>
</div>
</div>

<p>Note that here we have added braces around the variable <code>x</code> in our definition of
<code>STEP</code>. This lets us omit the number entirely when writing our proof:</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = STEP (STEP ZERO)
</pre></div>
</div>
</div>

<p>If Agda cannot, for whatever reason, infer the value of the implicit parameter,
yellow highlighting and an unsolved metavariable will be added, as before. In
those scenarios, you can manually specify the value of the implicit parameter by
using braces: </p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₁ : suc (suc (suc (suc zero))) even
proof₁ = STEP {suc (suc zero)} (STEP {zero} ZERO)
</pre></div>
</div>
</div>

<p>For <code>_even</code>, this is not usually necessary, but if you find yourself specifying
implicit parameters frequently, you may wish to consider making it explicit.</p>

<hr />

<h3 id="implication">Implication</h3>

<p>In Agda, an implication proposition corresponds to a <em>function type</em>.</p>

<p>When we prove an implication, say <code>A ⇒ B</code>, we assume the premise <code>A</code>, and
derive the conclusion <code>B</code>.  In terms of proof by construction, this
is the same as implementing a function—a function that, when given an argument
of type <code>A</code>, constructs an return value of type <code>B</code>. </p>

<p>In other words, given a proof (by construction) of some proposition
<code>A</code>, our function produces a proof of proposition <code>B</code>.
By writing such a function (and having Agda check it), we have constructed a
proof of <code>A ⇒ B</code>.</p>

<p>Consider the simple tautology <code>A ⇒ A</code>. 
Let’s prove this in Agda! </p>

<p>First, we prove it for the proposition that natural numbers exist, 
that is, “if natural numbers exist, then natural numbers exist.” </p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₂ : ℕ → ℕ
proof₂ ν = ν      -- type \nu for ν.
</pre></div>
</div>
</div>

<p>So, proof of this tautology corresponds to the identity function. The reason for
this is fairly clear: Given a proof of <code>A</code>, there’s one obvious way to produce
a proof of <code>A</code>: present the same proof you were just given!</p>

<hr />

<h3 id="universal-quantification">Universal Quantification</h3>

<p>It would be nice though, to make the above proof about <em>all</em> propositions, not merely
the proposition that natural numbers exist—after all, the proof is the same
regardless of the proposition involved!</p>

<p>To do this, we have to exploit Agda’s flexible type system a little. We make our
identity function take an additional parameter—a type. Given a type, we then
return an identity function, instantiated for that type.</p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₂′ : (A : Set) → A → A
proof₂′ _ x = x
</pre></div>
</div>
</div>

<p>The new type signature here means: Given some value of type <code>Set</code> (i.e., a type),
called <code>A</code>, return a function from <code>A</code> to <code>A</code>.  We take this to be equivalent to
the logical statement, “For any proposition <code>A</code>, <code>A ⇒ A</code>.” </p>

<p>In logic, the <em>universal quantifier</em> symbol <code>∀</code> means “for any” or “for all”. 
So, the above type signature could be stated as, $(\forall A) (A \Rightarrow A)$.
Making propositions about <em>all</em> members of a set (or universe) is called
<em>universal quantification</em>, and it corresponds to <em>parametric polymorphism</em>
(including Java generics and C++ templates) in type system lingo.</p>

<p>Now we can implement our special case proof, <code>proof₂</code>, in terms of the more
general <code>proof₂′</code>, as follows: </p>

<div><div class="CodeRay">
  <div class="code"><pre>proof₂ : ℕ → ℕ
proof₂ = proof₂′ ℕ
</pre></div>
</div>
</div>

<p>In other words, “to prove ℕ → ℕ, apply <code>proof₂′</code> to type ℕ.”</p>

<p>In the next section we will start a new Agda program so, before moving on, we
list the full contents of our first Agda program, which resides in the file
<a href="http://williamdemeo.github.io/downloads/code/agda/LearnYouAn2.agda">LearnYouAn2.agda</a>.</p>

<div><div class="CodeRay">
  <div class="code"><pre>module LearnYouAn2 where

  data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ

  _+_ : ℕ → ℕ → ℕ
  zero + n = n
  (suc n) + m = suc (n + m)

  data _even : ℕ → Set where
    ZERO : zero even
    STEP : ∀ x → x even → suc (suc x) even

  proof₁ : suc (suc (suc (suc zero))) even 
  proof₁ = STEP (suc (suc zero)) (STEP zero ZERO)

  proof₂ : ℕ → ℕ
  proof₂ ν = ν

  proof₂′ : (A : Set) → A → A
  proof₂′ _ x = x
</pre></div>
</div>
</div>

<hr />

<h3 id="conjunction">Conjunction</h3>

<p>Unlike universal quantification or implication, conjunction and disjunction do
not correspond to built-in types in Agda, however they are fairly
straightforward to define. </p>

<p>The <em>conjunction</em> of the propositions $P$ and $Q$ is denoted by 
$P\conj Q$.  Informally, to prove the conjunction $P\conj Q$, we prove each of
its components. If we have a proof each component, then we automatically have a
proof of their conjunction. Thus conjunction corresponds to a <em>pair</em> or a <em>tuple</em>
(more formally known as a <em>product type</em>) in Agda. </p>

<p>More formally, to give meaning to conjunction, we must say how to introduce the
judgment $P \conj Q\ \true$. A verification of $P \conj Q$ requires a proof of $P$ and
a proof of $Q$.  Thus, the introduction rule for conjunction is,</p>

<script type="math/tex; mode=display">\frac{P\ \true \quad Q\ \true}{P \conj Q\ \true}\quad \conj \mathrm{I}</script>

<p>Let’s introduce conjunction in Agda.  Create a file called <tt>IPL.agda</tt>
containing the following (and check it with <code>C-c C-l</code>):</p>

<div><div class="CodeRay">
  <div class="code"><pre>module IPL where

  data _∧_ (P : Set) (Q : Set) : Set where
    ∧-intro : P → Q → (P ∧ Q)
</pre></div>
</div>
</div>

<p>(The symbol <code>∧</code> is produced by typing <tt>\and</tt>.)</p>

<p>Here we’ve defined a new data type, this time it is <em>parameterized</em> by two
propositions, which make up the components of the conjunction. Conjunction
itself is also a proposition, and we give it the type Set.</p>

<p>Notice how the <code>∧-intro</code> constructor can only produce a proof of <code>P ∧ Q</code> if it
is passed both a proof of <code>P</code> and a proof of <code>Q</code>. This is how conjunction is
demonstrated <em>by construction</em>—it is impossible to construct a conjunction that
is not supported by proofs of each component.</p>

<p>We now prove some simple properties about conjunctions, such as <code>P ∧ Q ⇒ P</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre>  proof₁ : {P Q : Set} → (P ∧ Q) → P
  proof₁ (∧-intro p q) = p
</pre></div>
</div>
</div>

<p>This is the elimination rule sometimes called “and-elim-1” or “and-elim-left.”<br />
If we define a similar rule for “and-elim-2”, we have the following program:</p>

<div><div class="CodeRay">
  <div class="code"><pre>module IPL where

  data _∧_ (P : Set) (Q : Set) : Set where
    ∧-intro : P → Q → (P ∧ Q)

  proof₁ : {P Q : Set} → (P ∧ Q) → P
  proof₁ (∧-intro p q) = p

  proof₂ : {P Q : Set} → (P ∧ Q) → Q
  proof₂ (∧-intro p q) = q

</pre></div>
</div>
</div>

<hr />

<h3 id="bijection">Bijection</h3>

<p>Now that we have defined conjunction and implication, we can define a notion of
logical <em>equivalence</em>. Two propositions are <em>equivalent</em> if both propositions
can be considered to be the same. This is defined as: if one is true, the other
is also true. In logic, this is called <em>bijection</em> and is written as 
<code>A ⇔ B</code>. Bijection can be expressed simply as a conjunction of two implications:
If A is true then B is true, and if B is true then A is true. </p>

<div><div class="CodeRay">
  <div class="code"><pre>_⇔_ : (P : Set) → (Q : Set) → Set
a ⇔ b = (a → b) ∧ (b → a)
</pre></div>
</div>
</div>

<p>(The symbol <code>⇔</code> is produced by typing <tt>&lt;=&gt;</tt>.)</p>

<hr />

<h3 id="proving-conjunction-properties">Proving conjunction properties</h3>

<p>We can write programs (i.e. proofs) of the algebraic properties of
conjunction. The commutative property says that 
$A \conj B \Leftrightarrow B \conj A$.  Let’s prove it:</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧-comm′ : {P Q : Set} → (P ∧ Q) → (Q ∧ P)
∧-comm′ (∧-intro p q) = ∧-intro q p

∧-comm : {P Q : Set} → (P ∧ Q) ⇔ (Q ∧ P)
∧-comm = ∧-intro (∧-comm′ {P} {Q}) (∧-comm′ {Q} {P}) -- implicits provided for clarity only.
</pre></div>
</div>
</div>

<p>Remove the implicits and have Agda check the following:</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧-comm′ : {P Q : Set} → (P ∧ Q) → (Q ∧ P)
∧-comm′ (∧-intro p q) = ∧-intro q p

∧-comm : {P Q : Set} → (P ∧ Q) ⇔ (Q ∧ P)
∧-comm = ∧-intro ∧-comm′ ∧-comm′
</pre></div>
</div>
</div>

<p>Let’s also prove associativity.</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧-assoc₁ : { P Q R : Set } → ((P ∧ Q) ∧ R) → (P ∧ (Q ∧ R))
∧-assoc₁ (∧-intro (∧-intro p q) r) = ∧-intro p (∧-intro q r)

∧-assoc₂ : { P Q R : Set } → (P ∧ (Q ∧ R)) → ((P ∧ Q) ∧ R)
∧-assoc₂ (∧-intro p (∧-intro q r)) = ∧-intro (∧-intro p q) r

∧-assoc : { P Q R : Set } → ((P ∧ Q) ∧ R) ⇔  (P ∧ (Q ∧ R))
∧-assoc = ∧-intro ∧-assoc₁ ∧-assoc₂
</pre></div>
</div>
</div>

<hr />

<h3 id="disjunction">Disjunction</h3>

<p>If conjunction is a <em>pair</em>, because it requires <em>both</em> proofs to hold, then
disjunction is a <em>sum type</em> (also known as an <code>Either</code> type), because it only
requires one proof in order to hold. In order to model this in Agda, we add
<em>two</em> constructors to the type, one for each possible component of the
disjunction. </p>

<div><div class="CodeRay">
  <div class="code"><pre>data _∨_ (P Q : Set) : Set where
   ∨-intro₁ : P → P ∨ Q
   ∨-intro₂ : Q → P ∨ Q
</pre></div>
</div>
</div>

<p>Using this, we can come up with some interesting proofs. The simplest one to
prove is <em>disjunction elimination</em>, which is the rule 
<code>∀A B C ⇒ ((A ⇒ C) ∧ (B ⇒ C) ∧ (A ∨ B))⇒ C</code>. 
In other symbols, </p>

<script type="math/tex; mode=display">\frac{A \disj B \quad A \Rightarrow C  \quad B \Rightarrow C}{C}</script>

<p>In words, if $A$ implies $C$ and $B$ implies $C$, and
$A$ is true or $B$ is true, then if follows that $C$ is true.</p>

<div><div class="CodeRay">
  <div class="code"><pre>∨-elim : {A B C : Set} → (A → C) → (B → C) → (A ∨ B) → C
∨-elim ac bc (∨-intro₁ a) = ac a
∨-elim ac bc (∨-intro₂ b) = bc b
</pre></div>
</div>
</div>

<p>We can also prove the algebraic properties of disjunction, such as commutativity:</p>

<div><div class="CodeRay">
  <div class="code"><pre>∨-comm′ : {P Q : Set} → (P ∨ Q) → (Q ∨ P)
∨-comm′ (∨-intro₁ p) = ∨-intro₂ p
∨-comm′ (∨-intro₂ q) = ∨-intro₁ q

∨-comm : {P Q : Set} → (P ∨ Q) ⇔ (Q ∨ P)
∨-comm = ∧-intro ∨-comm′ ∨-comm′
</pre></div>
</div>
</div>

<p>The associativity proof is left as an exercise for the reader.</p>

<hr />

<h3 id="negation">Negation</h3>

<p>You have probably noticed if you’re familiar with boolean logic that I’ve
avoided mentioning <em>false</em> throughout this entire section. Unlike boolean logic,
Agda’s <em>intuitionistic</em> logic does not have a well-defined notion of “false”. In
<em>classical</em> and boolean logics, all propositions are considered to be either
true or false. Intuitionistic logic, by contrast, is purely <em>constructive</em>. You
can either construct a proof for a proposition, making it true, or you can fail to
construct a proof, making you feel bad.</p>

<p>The only “false” values that exist in intuitionistic logic, therefore, are
values for which <em>there can exist no proof</em>. In Agda, this corresponds to a type
that contains no values. We call this type <code>⊥</code>, pronounced “bottom”. We define
it like so:</p>

<div><div class="CodeRay">
  <div class="code"><pre>data ⊥ : Set where
</pre></div>
</div>
</div>

<p>That’s right. No, it’s not a mistake. There are no constructors for <code>⊥</code>. It is a
type for which it is <em>impossible</em> to produce a value. Having such a value allows
us to define negation (<code>¬A</code>) as true if <code>A</code> being true would mean bottom is true
(which is impossible). Or, in more formal terms:  <code>¬A ⇔ (A ⇒ ⊥)</code> </p>

<div><div class="CodeRay">
  <div class="code"><pre>¬ : Set → Set -- for ¬ type \neg
¬ A = A → ⊥
</pre></div>
</div>
</div>

<hr />

<h2 id="the-curry-howard-correspondence">The Curry Howard Correspondence</h2>

<p>This section has taught you how to encode propositional logic into Agda’s type
system. The correspondences discussed here between disjunction and sum types,
conjunction and product types, functions and implication, and propositions and
types are the fundamentals behind the 
<a href="http://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard Correspondence</a>.
Using these tools, you can encode any constructive proof in Agda, which covers a
vast range of possible proofs, including the vast majority of proofs encountered
in program verification.</p>

<p>Future sections will introduce relational equality, and begin proving some
theorems about the Peano numbers we introduced in the previous section.</p>

<hr />

<h1 id="hole-filling">Hole filling</h1>

<p>(This section did not appear in the original version of the tutorial.  It is
adapted from <a href="http://www.stephendiehl.com/posts/agda.html">Stephen Diehl’s tutorial</a>, 
is essentially independent of the rest of the tutorial, and could be read immediately 
after Section 1.)</p>

<p>Let’s get some practice creating some “much needed” gaps in our proofs and then
filling them in.  As we learned above, Agda calls such gaps “holes”.</p>

<p>Open a file called HoleFilling.agda and put the following code in it:</p>

<div><div class="CodeRay">
  <div class="code"><pre>module HoleFilling where

data Bool : Set where
  false : Bool
  true : Bool
</pre></div>
</div>
</div>

<p>Above we saw how to implement a general conjunction, but here we will implement a simpler 
(post-fix) conjunction for the <code>Bool</code> type in order to demonstrate the creation and removal of holes.</p>

<p>To implement conjunction for <code>Bool</code>, we merely have to give the value of the conjunction for each 
of the four possible pairs of <code>Bool</code> values.  We begin by entering the following 
(put this outside the indentation block of <code>data Bool</code>):</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧ : Bool → Bool → Bool
∧ a b = ?
</pre></div>
</div>
</div>

<p>Note that <code>Bool → Bool → Bool</code> indicates the types of arguments <code>∧</code> should expect
(namely, <code>∧</code> is a function from <code>Bool</code> type to <code>Bool → Bool</code> type).  Since Agda knows what to expect, 
it can write much of the function for us.  As usual, use <code>C-c C-l</code> to type-check the program, and 
Agda creates a hole where we had a question mark. Our program should now look like this</p>

<div><div class="CodeRay">
  <div class="code"><pre>module HoleFilling where

data Bool : Set where
  false : Bool
  true : Bool

∧ : Bool → Bool → Bool
∧ a b = {!!}
</pre></div>
</div>
</div>

<p>Now, with the cursor in the hole (i.e., at the braces { }), and with the hole highlighted, 
type <code>C-c C-,</code> and Agda should respond with a list of goals that we must accomplish in order to give a 
valid definition of <code>∧</code> for type <code>Bool</code>.</p>

<pre><code>Goal: Bool
————————————————————————————————————————————————————————————
b : Bool
a : Bool
</code></pre>

<p>With the cursor still in the hole, hit <code>C-c C-c</code> and Agda responds with
“pattern variables to case”, which prompts us to introduce a case for the first variable.
Next to the phrase  enter the variable <code>b</code>, to which Agda responds with </p>

<div><div class="CodeRay">
  <div class="code"><pre>∧ : Bool → Bool → Bool
∧ a false = {!!}
∧ a true = {!!}
</pre></div>
</div>
</div>

<p>Put the cursor in the first of the two new holes and again type <code>C-c C-c</code> but this time 
enter a in response to the “pattern variables to case” prompt.</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧ : Bool → Bool → Bool
∧ false false = {!!}
∧ true false = {!!}
∧ a true = {!!}
</pre></div>
</div>
</div>

<p>With the cursor in the hole, type <code>C-c C-c</code> and again enter a.</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧ : Bool → Bool → Bool
∧ false false = {!!}
∧ true false = {!!}
∧ false true = {!!}
∧ true true = {!!}
</pre></div>
</div>
</div>

<p>Finally, we fill in the right hand sides to comport with conjunction:</p>

<div><div class="CodeRay">
  <div class="code"><pre>∧ : Bool → Bool → Bool
∧ false false = false
∧ true false = false
∧ false true = false
∧ true true = true
</pre></div>
</div>
</div>

<p>Instead of filling in the holes in the end manually, you could
place the cursor in each of the holes and hit <code>C-c C-a</code>.
The result will be four <code>false</code>’s, which wouldn’t be a very 
useful definition of conjunction… so change the last <code>false</code> to <code>true</code>!</p>

<hr />

<h2 id="emacs-agda-mode-key-bindings">Emacs agda-mode key bindings</h2>

<p>Below is a list of the Emacs commands we encountered above.  For a more complete
 list, visit <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.EmacsModeKeyCombinations">the Agda Wiki</a>.</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Key binding</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Load</td>
      <td>C-c C-l</td>
    </tr>
    <tr>
      <td>Evaluate term</td>
      <td>C-c C-n</td>
    </tr>
    <tr>
      <td>Show goals</td>
      <td>C-c C-?</td>
    </tr>
    <tr>
      <td>Next goal</td>
      <td>C-c C-f</td>
    </tr>
    <tr>
      <td>Split obligation</td>
      <td>C-c C-space</td>
    </tr>
    <tr>
      <td>Split again</td>
      <td>C-c C-r</td>
    </tr>
    <tr>
      <td>Show Constraints</td>
      <td>C-c C-=</td>
    </tr>
    <tr>
      <td>Solve Constraints</td>
      <td>C-c C-s</td>
    </tr>
    <tr>
      <td>Agsy find proof term</td>
      <td>C-c C-a</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="copyright">Copyright</h1>

<p>Copyright (c) 2013, Liam O’Connor-Davis</p>

<p>All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>

<ul>
  <li>
    <p>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</p>
  </li>
  <li>
    <p>Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following
disclaimer in the documentation and/or other materials provided
with the distribution.</p>
  </li>
  <li>
    <p>Neither the name of Liam O’Connor-Davis nor the names of other
contributors may be used to endorse or promote products derived
from this software without specific prior written permission.</p>
  </li>
</ul>

<p><small>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
“AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</small></p>

<hr />

<h1 id="notes">Notes</h1>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><code>suc</code> standing for successor.  <a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Unlike Haskell, type declarations are mandatory.  <a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Don’t worry if you’re scared by that <code>∀</code> sign, all will be explained in time.  <a href="#fnref:3" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Don’t be scared by the term - structural recursion is when a recursive function follows the structure of a recursive data type - it occurs very frequently in functional programs.<a href="#fnref:4" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Isotopy]]></title>
    <link href="http://williamdemeo.github.io/2014/02/13/isotopy/"/>
    <updated>2014-02-13T19:21:00-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/13/isotopy</id>
    <content type="html"><![CDATA[<p><em>Equivalence of algebraic structures</em></p>

<p>Consider two finite algebras that are the same
except for a relabeling of the operations.
Our intuition tells us that these are simply different names for the same
mathematical structure.
Formally, however, not only are these distinct mathematical objects, but also
they are nonisomorphic.</p>

<p><em>Isotopy</em> is another well known notion of “sameness” that is 
broader than isomorphism. However, I recently proved a result that
shows why isotopy also fails to fully capture algebraic equivalence. 
<!-- more -->
$\def\bA{\bf A} \def\bB{\bf B} \def\bC{\bf C}$ </p>

<p>This post provides a little bit of background and motivation, with a
couple of examples of the problems that arise when trying to decide whether two 
algebraic objects are “equivalent.”</p>

<hr />

<h2 id="example">Example</h2>

<p>Let us consider an example of two algebras that are the same 
except for the naming of their operations.  (This is an 
elaboration on Exercises 5.1 in
<a href="http://books.google.com/books/about/Algebras_lattices_varieties.html">Algebras, Lattices, Varieties</a>.)</p>

<p>Let $\bA$ be an algebra of size 4 and label the elements of the universe $\{1,2,3,4\}$.
Suppose $\bA$ has two unary operations, $f^\bA$ 
and $g^\bA$, where $f^\bA$ is the permutation $(1,2)(3,4)$ and 
$g^\bA$ is the permutation $(1,3)(2,4)$.  </p>

<p>Thus, the operations permute the elements as follows:</p>

<p><img src="http://williamdemeo.github.io/images/permutations.png" width="150" height="250" /></p>

<p>The congruence lattice of $\bA$ is </p>

<script type="math/tex; mode=display">M_n \cong \{ x_A , \theta_1, \theta_2, \theta_3, 1_A \},</script>

<p>where, by abuse of notation, we identify the congruences with their corresponding
partitions as follows:</p>

<script type="math/tex; mode=display"> 1_A = \mid 1,2,3,4 \mid </script>

<script type="math/tex; mode=display"> \theta_1 = \mid 1, 2 \mid 3, 4 \mid \quad \theta_2 = \mid 1, 3 \mid 2, 4 \mid \quad \theta_3 =
\mid 1, 4 \mid 2, 3 \mid </script>

<script type="math/tex; mode=display">0_A = \mid 1 \mid 2 \mid 3 \mid 4 \mid </script>

<p>Now consider the algebras 
$\mathbf{A}/\theta_1$,
$\mathbf{A}/\theta_2$, and
$\mathbf{A}/\theta_3$ which have respective universes</p>

<script type="math/tex; mode=display">\{ \{1, 2\}, \{3, 4\}\}, \quad  \{ \{1, 3\}, \{2, 4\}\}, \quad 
\{ \{1, 4\}, \{2, 3\}\}.</script>

<p>It is clear that</p>

<script type="math/tex; mode=display">\bA \cong \mathbf{A}/\theta_1 \times \mathbf{A}/\theta_2 \cong
\mathbf{A}/\theta_1 \times\mathbf{A}/\theta_3 \cong \mathbf{A}/\theta_2
\times\mathbf{A}/\theta_3.</script>

<p>Also, no two factors are isomorphic.  This is because of the naming of their
respective operations.</p>

<p>The algebra $\mathbf{A}/\theta_1$ has operations $f^{\bA/\theta_1}$ and
$g^{\bA/\theta_1}$, where $g^{\bA/\theta_1}$ permutes the blocks 
$\{1, 2\}\longleftrightarrow  \{3, 4\}$
and $f^{\bA/\theta_1}$ leaves them fixed.</p>

<p>On the other hand, the algebra $\bA/\theta_2$ has operations $f^{\bA/\theta_2}$
and $g^{\bA/\theta_2}$, where $f^{\bA/\theta_2}$ permutes the blocks
$\{1, 3\} \longleftrightarrow \{2, 4\}$
and $g^{\bA/\theta_2}$ leaves them fixed.</p>

<p>Thus, the operation in $\bA/\theta_1$ corresponding to the symbol $f$ is
the identity, while in $\bA/\theta_2$ the $f$ symbol corresponds to the
nonidentity permutation. But apart from this trivial relabeling, these two
algebraic structures are the same. </p>

<p>This may be viewed as a minor technical issue that could be overcome by simply
viewing the two algebras as <em>nonindexed algebras</em> (see, e.g.,
<a href="http://dml.cz/dmlcz/106973">Polák</a>), and we can certainly say that
<em>up to a relabeling of the operation symbols,</em> the two algebras 
are isomorphic.</p>

<p>However, it would be preferable to have a notion of algebraic equivalence that
did not hinge on operation alignment.</p>

<hr />

<h2 id="deeper-problems">Deeper problems</h2>

<p>The example above was a simple, almost trivial illustration of how the
notion of isomorphic (indexed) algebras fails to capture our intuitive
understanding of what it means for two algebras to be structurally the same.
But there are examples that go deeper and are not as easy to side step.</p>

<p>Consider the Oates-Powell Theorem <a href="#references">1</a> which states that the variety
generated by a finite group has a finite equational basis. </p>

<p>In a <a href="https://github.com/williamdemeo/Isotopy/blob/master/pointedgroups.pdf?raw=true">1982 paper</a>
Roger Bryant proved that if we merely single out an element of the group and
giving it a label, then the resulting algebra (called a <em>pointed group</em>) generates
a variety that need not be finitely based.</p>

<hr />

<h2 id="isotopy">Isotopy</h2>

<p>Any reasonable notion of algebraic equivalence should at least respect
congruences lattice structure.
The congruence relations of algebras are the kernels of homomorphisms, and the 
congruence lattice is a basic “algebraic” feature of an algebra. Certainly we
cannot accept a notion of “sameness” that equates two algebras with different
congruence lattices (puting aside for now what it means for two congruence
lattices to be “different”).</p>

<p><em>Isotopy</em>  provides a notion of “sameness” of
algebras that is less demanding than isomorphism, so there is some hope that 
it provides a reasonably intuitive notion of algebraic equivalence. </p>

<p>But by the foregoing remark, if isotopy is to serve as a notion of algebraic
equivalence, we should at least demand that two isotopic algebras have the
“same” congruence lattices, and for two lattices to be the “same” in
any sense, they must have the same number of elements so that we can at least
find a bijection between them (even if it is not a “structure preserving”
bijection).</p>

<p>However, I recently proved that, for any number $N \in \mathbb{N}$, it’s easy to
construct a pair of isotopic algebras with congruence lattices that differ in
size by more than $N$ elements.  We see from this that there is no hope for
isotopy as a reasonable notion of algebraic equivalence.  (A link to my short
article describing the construction appears below.)</p>

<p>Later, we will explore Voevodsky’s <em>univalence</em> principle and try 
to write down the definitions of universal algebras as higher types so that we
can exploit the ideas of homotopy type theory in order to possibly arrive at a 
more useful, intuitionistic definition of algebraic equivalence.</p>

<hr />

<h2 id="open-github-repository">Open GitHub repository</h2>

<p>The <a href="https://github.com/williamdemeo/Isotopy">Isotopy GitHub repository</a>
contains
<a href="https://github.com/williamdemeo/Isotopy/blob/master/Isotopy.pdf?raw=true">my article</a>
in which I present isotopic algebras with congruence lattices that are vastly
different in size.</p>

<hr />

<h2 id="references">References</h2>

<ul>
  <li>[1] “Identical relations in finite groups,” S. Oates, M. B. Powell, J. Algebra
(1965).  </li>
  <li>[2] “The laws of finite pointed groups” R. M. Bryant, Bull. London Math. Soc,
14 (1982), 119-123. </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A problem of P&aacute;lfy and Saxl]]></title>
    <link href="http://williamdemeo.github.io/2014/02/13/a-problem-of-palfy-and-saxl/"/>
    <updated>2014-02-13T07:41:27-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/13/a-problem-of-palfy-and-saxl</id>
    <content type="html"><![CDATA[<p>Suppose the lattice shown below is a congruence lattice of an algebra.</p>

<p><img src="http://williamdemeo.github.io/images/PSM4.png" /></p>

<p><strong>Claim:</strong>
If the three $\alpha_i$’s pairwise permute, then all pairs in the lattice permute. 
<!-- more --></p>

<p>Whether or not this claim is true is a simplified version of a question left open by
Pálfy and Saxl at the end of
<a href="https://github.com/williamdemeo/PalfySaxlProblem/raw/master/PalfySaxl-ConLatAndFactGroups.pdf">their 1990 paper</a>. Below
is a more formal statement of the problem, and a link to my notes describing
a proposed method of solution.  There remains one gap in the proof, that I’m
not yet sure how to fill, but I am hopeful that the overall strategy will work.</p>

<hr />

<h3 id="graphical-composition">Graphical composition</h3>
<p>In an attempt to prove the claim above and its generalization, I apply
an idea described in
<a href="https://github.com/williamdemeo/PalfySaxlProblem/raw/master/Werner-PartLatConLat.pdf">Heinrich Werner’s paper</a>
called <em>graphical composition</em>.</p>

<hr />

<h3 id="the-problem">The Problem</h3>

<p>Before giving a more precise statement of the problem, let us recall a couple of
basic definitions.  Given two equivalence relations $\alpha$ and $\beta$ on a
set $X$, the relation </p>

<script type="math/tex; mode=display">\alpha \circ \beta = \{(x,y) \in X^2: (\exists z)(x \; \alpha \; z \; \beta \; y)\}</script>

<p>is called the <em>composition</em> of $\alpha$ and $\beta$, and if 
$\alpha \circ \beta = \beta \circ \alpha$ then $\alpha$ and $\beta$ are said to
<em>permute</em>.</p>

<p><strong>Problem.</strong>
$\def\bA{\bf A} \def\bB{\bf B}$
Let $\bA$ be a finite algebra with $\operatorname{Con} \bA$ isomorphic to
$M_n$, for some $n\geq 4$.  If three nontrivial congruences of $\bA$ pairwise
permute, does it follow that every pair of congruences of $\bA$ permute?</p>

<hr />

<h2 id="github-repository">GitHub repository</h2>
<p>My <a href="https://github.com/williamdemeo/PalfySaxlProblem">GitHub repository</a>
contains the following:</p>

<ul>
  <li><a href="https://github.com/williamdemeo/PalfySaxlProblem/raw/master/PalfySaxlProblem.pdf">my notes</a>  </li>
  <li><a href="https://github.com/williamdemeo/PalfySaxlProblem/raw/master/PalfySaxl-ConLatAndFactGroups.pdf">Pálfy and Saxl’s paper</a>  </li>
  <li><a href="https://github.com/williamdemeo/PalfySaxlProblem/raw/master/Werner-PartLatConLat.pdf">Werner’s paper</a>.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TypeFunc]]></title>
    <link href="http://williamdemeo.github.io/2014/02/13/typefunc/"/>
    <updated>2014-02-13T07:23:58-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/13/typefunc</id>
    <content type="html"><![CDATA[<p>I started a GitHub repository called TypeFunc in an effort to get my head around
the massive amount of online resources for learning about type theory, functional
programming, category theory, $\lambda$-calculus, and connections between
topology and computing. </p>

<!-- more -->

<p>At this point, <a href="https://github.com/williamdemeo/TypeFunc">the TypeFunc repository</a>
is mostly a collection of links, but it also includes notes and
software resources that I have found helpful.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Overalgebras]]></title>
    <link href="http://williamdemeo.github.io/2014/02/13/overalgebras/"/>
    <updated>2014-02-13T06:42:53-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/13/overalgebras</id>
    <content type="html"><![CDATA[<p>In the <a href="https://github.com/williamdemeo/Overalgebras">Overalgebras GitHub repo</a>
resides the article
<a href="https://github.com/williamdemeo/Overalgebras/raw/master/DeMeo-Expansions-AU-2013.pdf">Expansions of finite algebras and their congruence lattices</a>, <em>Algebra
Universalis</em>, <strong>69</strong>, 2013. 
Also included is the GAP software I wrote for constructing new finite algebras by
extending and expanding transitive G-sets, as described in the paper. </p>

<!-- more -->

<p>The published version of the paper is in the file <a href="https://github.com/williamdemeo/Overalgebras/raw/master/DeMeo-Expansions-AU-2013.pdf">DeMeo-Expansions-AU-2013.pdf</a>,
and is also available at <a href="http://link.springer.com">springer.com</a>. </p>

<p>In the file <a href="https://github.com/williamdemeo/Overalgebras/blob/master/gap2uacalc.g">gap2uacalc.g</a> is a GAP program that can be used on its own to convert GAP groups and G-sets into UACalc .ua files,
which can then be imported into the <a href="http://uacalc.org">Universal Algebra Calculator</a>.
See <a href="http://universalalgebra.wordpress.org/documentation/gap/gap-and-uacalc/">universalalgebra.org</a> for more information about <a href="https://github.com/williamdemeo/Overalgebras/blob/master/gap2uacalc.g">gap2uacalc.g</a>.</p>

<p>For questions, comments, or suggestions please <a href="https://github.com/williamdemeo/Overalgebras/issues">submit an issue</a>.</p>

<p>Thanks for your interest in this work!</p>

<p><a href="https://github.com/williamdemeo">@williamdemeo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IEProps]]></title>
    <link href="http://williamdemeo.github.io/2014/02/13/ieprops/"/>
    <updated>2014-02-13T06:42:42-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/13/ieprops</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/williamdemeo/IEProps">IEPost GitHub repository</a> contains a draft of the article
<a href="https://github.com/williamdemeo/IEProps/blob/master/CommAlg/DeMeo-IEProps-rev1.pdf">Interval enforceable properties of finite groups</a>, to appear in <em>Communications in Algebra</em>.</p>

<!-- more -->

<p>The paper has been accepted and is in the final review stage. It should appear in print sometime in 2014.
The original submission is available in the file <a href="https://github.com/williamdemeo/IEProps/blob/master/CommAlg/DeMeo-IEProps-rev1.pdf">DeMeo-IEProps-rev1.pdf</a>. The latest revision is in the tex directory.</p>

<p>For questions, comments, or suggestions please <a href="https://github.com/williamdemeo/IEProps/issues">submit an issue</a>.</p>

<p>Thanks for your interest in this work!</p>

<p><a href="https://github.com/williamdemeo">@williamdemeo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GroupSound]]></title>
    <link href="http://williamdemeo.github.io/2014/02/13/groupsound/"/>
    <updated>2014-02-13T04:23:41-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/13/groupsound</id>
    <content type="html"><![CDATA[<p><em>What does a nonabelian group sound like?</em></p>

<p><a href="http://soundmath.github.io/GroupSound/">The GroupSound project</a> is
about harmonic analysis on finite groups. Classical dsp filtering algorithms can
be implemented as operations involving functions (e.g., audio signals) defined
on a finite group. That is, the group serves as the domain, or “index set,” of
the functions.  In this project, we explore the idea of using the finite group 
as an adjustable parameter of a digital audio filter. 
<!-- more --></p>

<p>Underlying many digital signal processing (dsp) algorithms, in particular those
used for digital audio filters, is the convolution operation, which is a
weighted sum of translations $f(x-y)$. Most classical results of dsp are easily
and elegantly derived if we define our functions on $\mathbb{Z}/n\mathbb{Z}$, the
abelian group of integers modulo n. If we replace this underlying “index set”
with a nonabelian group, then translation may be written $f(y^{-1}x)$, and the
resulting audio filters arising from convolution naturally produce different
effects than those obtained with ordinary (abelian group) convolution. </p>

<p>By listening to samples produced using various nonabelian groups, we try to get
a sense of the “acoustical characters” of finite groups.  </p>

<p>Please visit
<a href="http://soundmath.github.io/GroupSound/">the GroupSound project webpage</a> for
more details. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cloning an Octopress repo]]></title>
    <link href="http://williamdemeo.github.io/2014/02/07/cloning-an-octopress-repo/"/>
    <updated>2014-02-07T18:46:19-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/07/cloning-an-octopress-repo</id>
    <content type="html"><![CDATA[<p>When attempting to clone my Octopress repository on a new machine, I had the
same  <code>Updates were rejected</code> problem that is described on <a href="http://weishi.github.io/blog/2013/07/24/setup-an-existing-octopress-repository-after-git-clone/">this page</a>.
Based on the information provided on that page, combined with a few other
commands required for Ubuntu machines, this post provides instructions for
cloning an Octopress repository.<br />
<!-- more --></p>

<p>(This works on Ubuntu 13.10 and probably other variants.)</p>

<hr />

<ol>
  <li>
    <p>Make sure ruby1.9.1-dev and gem are installd:</p>

    <pre><code>sudo apt-get install ruby1.9.1-dev gem
gem install bundler
rbenv rehash
</code></pre>
  </li>
  <li>
    <p>Get the source and initialize empty _deploy directory:</p>

    <pre><code>git clone git@github.com:williamdemeo/williamdemeo.github.io.git
cd williamdemeo.github.io/
git checkout source
mkdir _deploy
cd _deploy
git init
git remote add -t master -f origin git@github.com:williamdemeo/williamdemeo.github.io.git
cd ..
</code></pre>
  </li>
  <li>
    <p>Use bundler to check that all the dependencies in GemFile are met:</p>

    <pre><code>bundle install
</code></pre>
  </li>
  <li>
    <p>Generate the pages and deploy:</p>

    <pre><code>rake generate
rake deploy
</code></pre>
  </li>
</ol>

<p><strong>Troubleshooting.</strong> 
If <code>rake generate</code> produces “invalid byte sequence in US-ASCII” then try the following: </p>

<pre><code>    # from the command line
    export LANG=en_US.UTF-8
    export LANGUAGE=en_US.UTF-8
    export LC_ALL=en_US.UTF-8
    bundle
</code></pre>

<hr />

<h2 id="workflow">Workflow</h2>

<ol>
  <li>
    <p>Make some changes, e.g., create a new post:</p>

    <pre><code>rake new_post["title"]
</code></pre>
  </li>
  <li>
    <p>Posts live in <code>source/_posts</code>.  Edit one and push the changes to source
branch either directly with Magit or with</p>

    <pre><code>git add .
git commit -am "explanation of changes" 
git push origin source
</code></pre>
  </li>
  <li>
    <p>Now preview the changes: <code>rake preview</code> and load <code>http://localhost:4000</code> in browser.</p>
  </li>
  <li>
    <p>When satisfied, <code>rake deploy</code>.</p>
  </li>
</ol>

<hr />

<h2 id="other-resources">Other Resources</h2>

<ul>
  <li><a href="http://stackoverflow.com/questions/14245822/cannot-install-redcloth">Get RedCloth installed properly on Ubuntu</a>   </li>
  <li><a href="http://paulsturgess.co.uk/blog/2013/04/24/hello-octopress-and-github-pages/">Setup Octopress, pick a theme, maintain with rake</a>  </li>
  <li><a href="http://weishi.github.io/blog/2013/07/24/setup-an-existing-octopress-repository-after-git-clone/">Setup an existing Octopress repo</a>  </li>
  <li><a href="http://blog.zerosharp.com/clone-your-octopress-to-blog-from-two-places/">Maintain Octopress repo on multiple machines</a>  </li>
  <li><a href="http://www.lucypark.kr/blog/2013/02/25/mathjax-kramdown-and-octopress/">Get MathJax working (one way)</a></li>
  <li><a href="http://www.idryman.org/blog/2012/03/10/writing-math-equations-on-octopress/">Get MathJax working (another)</a>  </li>
  <li><a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">Select a nice theme</a>  </li>
  <li><a href="http://stackoverflow.com/questions/17031651/invalid-byte-sequence-in-us-ascii-argument-error-when-i-run-rake-dbseed-inra">Troubleshoot UTF-8 locale</a>  </li>
  <li><a href="http://blog.bigdinosaur.org/changing-octopresss-header/">Changing fonts and colors</a></li>
  <li>Carl Boettiger has an awesome <a href="http://carlboettiger.info/index.html">open notebook</a>.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diaconescu's Theorem]]></title>
    <link href="http://williamdemeo.github.io/2014/02/05/diaconescus-theorem/"/>
    <updated>2014-02-05T20:52:59-07:00</updated>
    <id>http://williamdemeo.github.io/2014/02/05/diaconescus-theorem</id>
    <content type="html"><![CDATA[<p>I learned about
<a href="http://en.wikipedia.org/wiki/Diaconescu%27s_theorem">Diaconescu’s Theorem</a>
from <a href="http://video.ias.edu/members/1213/0318-AndrejBauer">Andrej Bauer’s lecture</a>.</p>

<p>This post describes the proof as it was presented by Bauer.  These notes are rough
and intended for my own reference.
Please see <a href="http://dorais.org/archives/1031">François Dorais’ blog post</a> 
for a nice discussion of this topic.</p>

<!-- more -->

<hr />

<ul>
  <li>
    <p><strong>The Axiom of Choice</strong> (AC) states that if $\mathcal{S}$ is a collection of nonempty
sets, then there is a choice function $f$ that can be used to select an element
from each set in $\mathcal{S}$.</p>
  </li>
  <li>
    <p><strong>Law of the Excluded Middle</strong> (LEM) states that $P$ is a proposition, then
$P \bigvee \neg P$.</p>
  </li>
  <li>
    <p><strong>Diaconescu’s Theorem:</strong> AC $\rightarrow$ LEM.</p>

    <p><strong>Proof:</strong>  Assume AC.  Let $P$ be any proposition.  We will prove
$P \bigvee \neg P$.</p>

    <p>Define the set $\mathbf{2} = \{0, 1\} = \{x \mid x = 0 \bigvee x= 1\}$.</p>

    <p>Define the following sets:</p>

<script type="math/tex; mode=display">A = \{x \mid (x = 0) \bigvee P\}</script>

<script type="math/tex; mode=display">B = \{y \mid (y = 1) \bigvee P\}</script>

    <p>Note that $P \Rightarrow A = B = \mathbf{2}$. Therefore,
$A \neq B \Rightarrow \neg P$.</p>

    <p>Both of the sets $A$ and $B$ are nonempty, since 0 belongs to $A$ and 1 belongs to $B$. </p>

    <p>Therefore, $\{A, B\}$ is a set of nonempty sets, so by AC we have a choice function,
<!-- Note that the set $\\{A, B\\}$ is defined as $\\{A, B\\} = \\{X \in
\mathbf{Set} | X = A \bigvee X = B\\}$ (by pairing axiom).--></p>

<script type="math/tex; mode=display">f : \{A, B\} \rightarrow A \cup B, \text{ and note that } A\cup B = \{0, 1\}.</script>

    <p>Now, because equality on $\mathbb{N}$ <em>is</em> decidabile (which can be proved
by induction on $\mathbb{N}$), we can consider cases:</p>

    <p>If $f(A) = 0 = f(B)$, then $0 \in B$, so $P$.</p>

    <p>If $f(A) = 1 = f(B)$, then $1 \in A$, so $P$.</p>

    <p>If $f(A) \neq f(B)$, then $A \neq B$ so $P$ cannot hold.
(Recall, $P \Rightarrow A = B = \mathbf{2}$.)</p>

    <p>We have covered all cases and found that $P \bigvee \neg P$ holds. 
<span style="float:right">∎</span></p>
  </li>
</ul>

<hr />

<h2 id="coq">Coq</h2>

<p><a href="http://coq.inria.fr/V8.1/stdlib/Coq.Logic.Diaconescu.html">Proofs of Diaconescu’s Theorem in Coq</a></p>

<hr />

<h2 id="appendix">Appendix</h2>

<ul>
  <li><strong>Decidable Sets.</strong>
A set $S$ is <strong>decidable</strong> if for all $x, y \in S$ we have
$x = y \bigvee x \neq y$. The empty set and singleton sets are trivially
decidable, but some more complicated sets are decidable too. For example, one
can use induction to show that the set of natural numbers is decidable. </li>
</ul>

<hr />

<h2 id="references">References</h2>

<ul>
  <li>Diaconescu, “Axiom of choice and complementation,” <em>Proc. AMS</em> 51 (1975), 176–178. <a href="http://dx.doi.org/10.1090/S0002-9939-1975-0373893-X">doi:10.1090/S0002-9939-1975-0373893-X</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
